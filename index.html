<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover, user-scalable=no" />
  <title>StikBox — Beta</title>
  
  <!-- SEO Meta -->
  <meta name="description" content="StikBox is a sandbox particle simulation game in your browser. Play with sand, water, fire, lava, oil, smoke, and more in an interactive world.">
  <meta name="keywords" content="StikBox, sandbox game, particle simulator, falling sand, browser game, fire, water, lava, physics simulation, beta">
  <meta name="author" content="StephenDev0">
  <meta name="robots" content="index, follow">
  <link rel="canonical" href="https://stephendev0.github.io/StikBox/" />

  <!-- Open Graph / Facebook -->
  <meta property="og:title" content="StikBox — Sandbox Particle Simulation (Beta)">
  <meta property="og:description" content="Experiment with sand, water, lava, fire, oil, and more in StikBox — a browser-based sandbox simulation game.">
  <meta property="og:type" content="website">
  <meta property="og:url" content="https://stephendev0.github.io/StikBox/">

  <!-- Twitter -->
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="StikBox — Sandbox Particle Simulation (Beta)">
  <meta name="twitter:description" content="A fun, interactive sandbox particle game. Play with sand, water, fire, and more.">

  <!-- Schema.org Structured Data -->
  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "VideoGame",
    "name": "StikBox",
    "description": "A sandbox particle simulation browser game where you play with sand, water, lava, fire, oil, smoke, and more.",
    "author": {
      "@type": "Person",
      "name": "StephenDev0"
    },
    "genre": ["Simulation", "Sandbox"],
    "operatingSystem": "Any (Web Browser)",
    "applicationCategory": "Game",
    "url": "https://stephendev0.github.io/StikBox/"
  }
  </script>

  <style>
    :root{
      --bg:#0b0f14;
      --text:#e9eef5; --muted:#9aa6b2;
      --accent:#89b4ff; --accent-2:#ffd166;
      --ok:#2dcc70; --warn:#ffb020; --danger:#ff6b6b;
      --stroke:rgba(255,255,255,.16);
      --panel:rgba(255,255,255,.06);
      --panel-2:rgba(255,255,255,.07);
      --radius:20px;

      /* Controls */
      --ui-scale: 0.55;      /* global shrink */
      --ui-comp: calc(1 / var(--ui-scale));   /* compensate sizes post-scale */
      --chrome: 150px;       /* header + toolbar + margins to subtract */

      /* Canvas height targets (visual, pre-scale) */
      --canvas-min-vis: 78svh;  /* never shorter than this */
      --canvas-max-vis: 1100px; /* hard visual cap */
    }

    *{box-sizing:border-box}
    html,body{height:100%}
    html{ -webkit-text-size-adjust:100%; text-size-adjust:100%; }
    input, button, select, textarea { font-size:16px; }

    body{
      margin:0; color:var(--text); font:500 15px/1.3 system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial;
      background:
        radial-gradient(40% 60% at 20% 15%, rgba(99,102,241,.18), transparent 60%),
        radial-gradient(35% 55% at 80% 80%, rgba(59,130,246,.14), transparent 60%),
        linear-gradient(180deg, #0c1118, #0a0e14 30%, #090d13 60%, #070b10);
    }

    /* Global UI scale */
    .ui-root{
      transform: scale(var(--ui-scale));
      transform-origin: top left;
      width: calc(100% / var(--ui-scale));
      height: calc(100% / var(--ui-scale));
    }

    .shell{display:flex; flex-direction:column; min-height:100dvh;}

    .glass{
      background:rgba(255,255,255,.06);
      backdrop-filter:saturate(1.2) blur(18px);
      -webkit-backdrop-filter:saturate(1.2) blur(18px);
      border:1px solid var(--stroke);
      border-radius:var(--radius);
      box-shadow:0 20px 50px rgba(0,0,0,.25);
    }
    .glass-soft{
      background:rgba(255,255,255,.05);
      backdrop-filter:saturate(1.2) blur(14px);
      -webkit-backdrop-filter:saturate(1.2) blur(14px);
      border:1px solid rgba(255,255,255,.12);
      border-radius:16px;
    }
    .btn{
      border:1px solid var(--stroke);
      background:rgba(255,255,255,.06);
      color:var(--text);
      border-radius:12px;
      padding:.48rem .7rem;
      cursor:pointer; display:inline-flex; align-items:center; gap:.35rem; user-select:none; white-space:nowrap;
      box-shadow:0 6px 20px rgba(0,0,0,.22) inset, 0 6px 16px rgba(0,0,0,.15);
      transition:transform .06s ease, background .2s ease, border-color .2s ease;
    }
    .btn:hover{ background:rgba(255,255,255,.1); }
    .btn:active{ transform:translateY(1px) scale(.99); }
    .btn[disabled]{opacity:.6; cursor:not-allowed}

    .toolbar{
      position:sticky; top:0; z-index:8; display:flex; flex-wrap:wrap; align-items:center; gap:.6rem;
      padding:.6rem .7rem;
      background:rgba(14,18,26,.5);
      backdrop-filter:blur(16px) saturate(1.2);
      -webkit-backdrop-filter:blur(16px) saturate(1.2);
      border-bottom:none;
    }
    .brand{display:flex; align-items:center; gap:.6rem; padding-right:.4rem}
    .brand .logo{width:42px; height:42px; border-radius:14px; background:
      radial-gradient(60% 60% at 30% 30%, rgba(255,255,255,.25), transparent 60%),
      conic-gradient(from 220deg, var(--accent), var(--accent-2) 60%, #7dd3fc);
      border:1px solid var(--stroke);
      box-shadow:0 12px 30px rgba(0,0,0,.28);
    }
    .beta{margin-left:8px; border:1px solid var(--stroke); padding:.15rem .45rem; border-radius:999px; color:#ffd166; font-weight:800; letter-spacing:.3px; background:rgba(255,255,255,.06)}

    .group{display:flex; align-items:center; gap:.4rem; padding:.35rem; border-radius:16px; border:1px solid var(--stroke); background:rgba(255,255,255,.05)}
    .seg{display:flex; gap:.25rem; overflow:auto; -webkit-overflow-scrolling:touch}
    .seg>input{display:none}
    .seg>label{border:1px solid var(--stroke); background:rgba(255,255,255,.06); color:var(--text); border-radius:10px; padding:.45rem .6rem; cursor:pointer; display:inline-flex; align-items:center; gap:.35rem; user-select:none; white-space:nowrap}
    .seg>input:checked+label{background:rgba(255,255,255,.14); border-color:rgba(255,255,255,.28)}

    .slider{appearance:none; width:140px; height:8px; background:linear-gradient(90deg, rgba(255,255,255,.06), rgba(255,255,255,.04)); border-radius:999px; outline:none; border:1px solid rgba(255,255,255,.14)}
    .slider::-webkit-slider-thumb{appearance:none; width:18px; height:18px; border-radius:50%; background:var(--accent); border:2px solid #0e1a26; cursor:pointer; box-shadow:0 0 0 4px rgba(137,180,255,.18)}
    .slider::-moz-range-thumb{width:18px; height:18px; border:none; border-radius:50%; background:var(--accent); cursor:pointer}

    /* Layout: canvas | goals (no overlap) */
    .canvas-wrap{
      position:relative;
      display:grid;
      grid-template-columns: 1fr 280px;
      gap:14px;
      padding:10px;
      align-items:start;
      overflow:auto;
    }

    .canvas-box{
      position:relative; resize:vertical; overflow:auto;
      width:100%;
      /* Clamp height and correct for global --ui-scale so visual size matches intent */
      height: clamp(
        calc(var(--canvas-min-vis) * var(--ui-comp)),
        calc((100dvh - var(--chrome)) * var(--ui-comp)),
        calc(var(--canvas-max-vis) * var(--ui-comp))
      );
      max-height: calc(var(--canvas-max-vis) * var(--ui-comp));
      max-width:100%;
      border-radius:18px;
    }

    canvas{display:block; background:#0a0e14; border:1px solid var(--stroke); border-radius:18px; image-rendering:pixelated; box-shadow:0 8px 40px rgba(0,0,0,.35), 0 0 0 1px rgba(255,255,255,.06) inset; outline:none}
    .hint{position:absolute; left:16px; bottom:16px; color:var(--muted); font-size:.85rem; background:rgba(0,0,0,.35); padding:.25rem .5rem; border-radius:8px; border:1px solid rgba(255,255,255,.1)}

    .sidepanel{position:relative; display:flex; flex-direction:column; gap:12px; min-width:260px}
    .card{padding:12px; border-radius:18px}
    .card h4{margin:.2rem 0 .5rem 0; font-size:.95rem; color:#d9e1ee}
    .ach-list{display:grid; gap:6px}
    .ach{display:flex; justify-content:space-between; align-items:center; padding:.45rem .6rem; border-radius:12px; background:rgba(255,255,255,.06); border:1px solid var(--stroke)}
    .ach .k{opacity:.9}

    .role-pop{position:absolute; transform:translateY(42px); border:1px solid var(--stroke); border-radius:14px; padding:8px; display:none; gap:6px}
    .role-pop.open{display:flex}

    @media (max-width:900px){
      .canvas-wrap{grid-template-columns: 1fr}
      .sidepanel{grid-row:3}
    }
  
    /* NPC controls visible */
    /* Hide portal UI when disabled */
    #m-portalB, label[for="m-portalB"],
    #m-portalO, label[for="m-portalO"],
    .group[title="Portals"] { display:none !important; }

</style>
</head>
<body>
  <div class="ui-root">
  <div class="shell">
    <!-- Header -->
    <div class="glass" style="margin:10px 10px 8px; padding:10px;">
      <div class="toolbar" role="toolbar" aria-label="StikBox controls">
        <div class="brand">
          <div class="logo" aria-hidden></div>
          <div>
            <div style="font-weight:800; letter-spacing:.2px">StikBox</div>
            <div style="color:var(--muted); font-size:.86rem">V 0.0.2</div>
          </div>
          <span class="beta">BETA</span>
        </div>

        <div class="group" title="Materials">
          <div class="seg" id="materialSeg" role="radiogroup" aria-label="Material">
            <input type="radio" name="mat" id="m-sand" value="sand" checked><label for="m-sand" title="Sand">🟨</label>
            <input type="radio" name="mat" id="m-water" value="water"><label for="m-water" title="Water">💧</label>
            <input type="radio" name="mat" id="m-stone" value="stone"><label for="m-stone" title="Stone">🪨</label>
            <input type="radio" name="mat" id="m-metal" value="metal"><label for="m-metal" title="Metal">🔩</label>
            <input type="radio" name="mat" id="m-ice" value="ice"><label for="m-ice" title="Ice">🧊</label>
            <input type="radio" name="mat" id="m-wood" value="wood"><label for="m-wood" title="Wood">🪵</label>
            <input type="radio" name="mat" id="m-oil" value="oil"><label for="m-oil" title="Oil">🛢️</label>
            <input type="radio" name="mat" id="m-lava" value="lava"><label for="m-lava" title="Lava">🌋</label>
            <input type="radio" name="mat" id="m-fire" value="fire"><label for="m-fire" title="Fire">🔥</label>
            <input type="radio" name="mat" id="m-smoke" value="smoke"><label for="m-smoke" title="Smoke">☁️</label>
            <input type="radio" name="mat" id="m-steam" value="steam"><label for="m-steam" title="Steam">💨</label>
            <input type="radio" name="mat" id="m-snow" value="snow"><label for="m-snow" title="Snow">❄️</label>
            <input type="radio" name="mat" id="m-acid" value="acid"><label for="m-acid" title="Acid">🧪</label>
            <input type="radio" name="mat" id="m-glass" value="glass"><label for="m-glass" title="Glass">🔷</label>
            <input type="radio" name="mat" id="m-seed" value="seed"><label for="m-seed" title="Seed">🌰</label>
            <input type="radio" name="mat" id="m-plant" value="plant"><label for="m-plant" title="Plant">🌱</label>
            <input type="radio" name="mat" id="m-wire" value="wire"><label for="m-wire" title="Wire">🔌</label>
            <input type="radio" name="mat" id="m-spark" value="spark"><label for="m-spark" title="Spark">⚡</label>
            <input type="radio" name="mat" id="m-battery" value="battery"><label for="m-battery" title="Battery">🔋</label>
            <input type="radio" name="mat" id="m-lamp" value="lamp"><label for="m-lamp" title="Lamp">💡</label>
            <input type="radio" name="mat" id="m-heater" value="heater"><label for="m-heater" title="Heater">♨️</label>
            <input type="radio" name="mat" id="m-fan" value="fan"><label for="m-fan" title="Fan">🌀</label>
            <input type="radio" name="mat" id="m-portalB" value="portalB"><label for="m-portalB" title="Portal Blue">🔵</label>
            <input type="radio" name="mat" id="m-portalO" value="portalO"><label for="m-portalO" title="Portal Orange">🟠</label>
            <input type="radio" name="mat" id="m-gas" value="gas"><label for="m-gas" title="Gas">🫧</label>
            <input type="radio" name="mat" id="m-solar" value="solar"><label for="m-solar" title="Solar">🔆</label>
            <input type="radio" name="mat" id="m-sensor" value="sensor"><label for="m-sensor" title="Sensor">🎛️</label>
            <input type="radio" name="mat" id="m-sprinkler" value="sprinkler"><label for="m-sprinkler" title="Sprinkler">🚿</label>
            <input type="radio" name="mat" id="m-tnt" value="tnt"><label for="m-tnt" title="TNT">🧨</label>
            <input type="radio" name="mat" id="m-people" value="people"><label for="m-people" title="Spawn person">👤</label>
            <input type="radio" name="mat" id="m-erase" value="erase"><label for="m-erase" title="Erase">🧽</label>
          </div>
        </div>

        <div class="group" title="Brush">
          <label>Brush</label>
          <button class="btn" id="brushDec">–</button>
          <input id="brush" class="slider" type="range" min="1" max="28" value="8" />
          <button class="btn" id="brushInc">+</button>
          <span id="brushOut" style="opacity:.75">8 px</span>
          <div class="seg" id="shapeSeg" role="radiogroup" aria-label="Brush shape">
            <input type="radio" name="shape" id="s-circ" value="circle" checked><label for="s-circ" title="Circle">◯</label>
            <input type="radio" name="shape" id="s-square" value="square"><label for="s-square" title="Square">■</label>
            <input type="radio" name="shape" id="s-spray" value="spray"><label for="s-spray" title="Spray">⋅⋅⋅</label>
          </div>
          <div class="seg" id="eraseSeg" role="radiogroup" aria-label="Erase mode">
            <input type="radio" name="erase" id="e-all" value="all" checked><label for="e-all">Erase: All</label>
            <input type="radio" name="erase" id="e-type" value="type"><label for="e-type">Erase: Current</label>
          </div>
        </div>

        <div class="group" title="Simulation">
          <button class="btn" id="toggle">⏸️ Pause</button>
          <button class="btn" id="step">⏭️ Step</button>
          <label>Speed</label>
          <input id="speed" class="slider" type="range" min="0" max="4" step=".25" value="1.5" />
          <button class="btn" id="undo">↶ Undo</button>
          <button class="btn" id="redo">↷ Redo</button>
        </div>

        <div class="group" title="View">
          <button class="btn" id="helpBtn">❔ Help</button>
          <button class="btn" id="zoomIn">＋</button>
          <button class="btn" id="zoomOut">－</button>
          <button class="btn" id="zoomReset">100%</button>
          <label style="display:inline-flex; align-items:center; gap:.35rem"><input type="checkbox" id="togHeat"> Heatmap</label>
          <label style="display:inline-flex; align-items:center; gap:.35rem"><input type="checkbox" id="togDay" checked> Day/Night</label>
          <label style="display:inline-flex; align-items:center; gap:.35rem"><input type="checkbox" id="panMode"> Pan</label>
          <label style="display:inline-flex; align-items:center; gap:.35rem"><input type="checkbox" id="togWaterFX" checked> Water FX</label>
          <label style="display:inline-flex; align-items:center; gap:.35rem"><input type="checkbox" id="togBloom" checked> Bloom</label>
          <label style="display:inline-flex; align-items:center; gap:.35rem"><input type="checkbox" id="autosave" checked> Autosave</label>
        </div>

        <div class="group" title="Portals">
          <label>Portal Facing</label>
          <div class="seg" id="faceSegB" role="radiogroup" aria-label="Blue portal face">
            <input type="radio" name="pfaceB" id="pfb-up" value="up" checked><label for="pfb-up" title="Blue: Up">🔵↑</label>
            <input type="radio" name="pfaceB" id="pfb-right" value="right"><label for="pfb-right" title="Blue: Right">🔵→</label>
            <input type="radio" name="pfaceB" id="pfb-down" value="down"><label for="pfb-down" title="Blue: Down">🔵↓</label>
            <input type="radio" name="pfaceB" id="pfb-left" value="left"><label for="pfb-left" title="Blue: Left">🔵←</label>
          </div>
          <div class="seg" id="faceSegO" role="radiogroup" aria-label="Orange portal face">
            <input type="radio" name="pfaceO" id="pfo-up" value="up" checked><label for="pfo-up" title="Orange: Up">🟠↑</label>
            <input type="radio" name="pfaceO" id="pfo-right" value="right"><label for="pfo-right" title="Orange: Right">🟠→</label>
            <input type="radio" name="pfaceO" id="pfo-down" value="down"><label for="pfo-down" title="Orange: Down">🟠↓</label>
            <input type="radio" name="pfaceO" id="pfo-left" value="left"><label for="pfo-left" title="Orange: Left">🟠←</label>
          </div>
        </div>

        <div class="group" title="Save/Load">
          <button class="btn" id="save">💾 Save</button>
          <button class="btn" id="load">📂 Load</button>
          <input type="file" id="file" accept="application/json" style="display:none" />
        </div>

        <span id="stat" style="opacity:.85; padding:.25rem .5rem; border:1px solid var(--stroke); border-radius:10px; background:rgba(255,255,255,.05)">0×0 • 0 fps • 0 parts</span>
      </div>
    </div>

    <div class="canvas-wrap">
      <div class="canvas-box"><canvas id="c" tabindex="0" aria-label="StikBox world"></canvas></div>
      <div class="hint">Two-finger pinch to zoom • Hold <kbd>Shift</kbd> to place faster</div>

      <div class="sidepanel">
        <div class="card glass-soft">
          <h4 id="goalsHeader">Goals (coming soon)</h4>
          <div class="ach-list" id="achList" style="display:none"></div>
        </div>
        <div class="card glass-soft">
          <h4>Tips</h4>
          <div style="color:#c5cedb; font-size:.92rem; line-height:1.35">
            Build a stone dam, pour oil over water, add spark → 🔥. <br>
            Miners drop piles, builders collect, farmers plant by water, firefighters douse flames.
          </div>
        </div>
      </div>

      <!-- Role popover -->
      <div class="role-pop glass-soft" id="rolePop">
        <button class="btn" data-role="builder">🧱 Builder</button>
        <button class="btn" data-role="miner">⛏️ Miner</button>
        <button class="btn" data-role="farmer">🌱 Farmer</button>
        <button class="btn" data-role="firefighter">🚒 Firefighter</button>
        <button class="btn" data-role="random">🎲 Random</button>
      </div>

      <!-- Help Modal -->
      <div id="helpModal" class="glass" style="position:fixed; inset:0; display:none; place-items:center; background:rgba(0,0,0,.35); z-index:50;">
        <div class="glass-soft" style="max-width:720px; width:calc(100% - 40px); border-radius:18px; padding:14px; border:1px solid rgba(255,255,255,.18); box-shadow:0 30px 80px rgba(0,0,0,.45)">
          <div style="display:flex; justify-content:space-between; align-items:center; gap:8px; margin-bottom:8px">
            <h3 style="margin:0; font-size:1.05rem; letter-spacing:.2px">StikBox — Help & Shortcuts</h3>
            <button class="btn" id="helpClose">✕</button>
          </div>
          <div style="display:grid; gap:8px; color:#d9e1ee; font-size:.95rem; line-height:1.4">
            <div class="glass-soft" style="padding:10px">
              <b>Controls</b>
              <ul style="margin:.4rem 0; padding-left:1.1rem">
                <li><b>Click / drag</b>: paint using selected material</li>
                <li><b>Shift</b> while painting: place faster</li>
                <li><b>Pan</b> toggle: drag canvas to pan; pinch to zoom</li>
                <li><b>Space</b>: pause/play • <b>+</b>/<b>-</b>: brush size • <b>R</b>: reset</li>
              </ul>
            </div>
            <div class="glass-soft" style="padding:10px">
              <b>People</b>
              <ul style="margin:.4rem 0; padding-left:1.1rem">
                <li>Spawn with 👤. They wander with gravity.</li>
                <li>Roles: 🧱 Builder, ⛏️ Miner, 🌱 Farmer, 🚒 Firefighter.</li>
                <li>Firefighters douse adjacent 🔥; Miners chip stone into piles; Farmers till sand near water.</li>
              </ul>
            </div>
            <div class="glass-soft" style="padding:10px">
              <b>New materials</b>
              <ul style="margin:.4rem 0; padding-left:1.1rem">
                <li>🪵 Wood: static, flammable near 🔥/🌋/⚡</li>
                <li>🔷 Glass: inert solid</li>
                <li>🧪 Acid: flows like water; dissolves stone/metal/plant/ice/wire</li>
                <li>💨 Steam: rises, then condenses into 💧</li>
                <li>❄️ Snow: powder like sand; melts to 💧 near heat</li>
                <li>🌰 Seed + 🌱 Plant: grow near 💧</li>
                <li>🔋 Battery: powers adjacent 🔌 Wire (⚡ pulses)</li>
                <li>💡 Lamp: lights up near ⚡</li>
                <li>♨️ Heater: turns 💧 to 💨, melts 🧊/❄️, ignites fuel</li>
                <li>🌀 Fan: pushes 💨/☁️/🔥 upward</li>
                <!-- Portals disabled for now -->
                <li>🫧 Gas: rises like smoke; ignites into 🔥 with ⚡/🔥/🌋</li>
                <li>🔆 Solar: emits ⚡ to wires during day</li>
                <li>🎛️ Sensor: emits ⚡ when near 👤 or 🔥</li>
                <li>🚿 Sprinkler: emits 💧 when powered by ⚡</li>
                <li>Glass forging: 🟨 near 🔥/🌋 can become 🔷 over time</li>
              </ul>
            </div>
          </div>
        </div>
      </div>

    </div> <!-- /canvas-wrap -->
  </div> <!-- /shell -->
  </div> <!-- /ui-root -->

<script>
(() => {
  // ===== Types & colors =====
  const T = { EMPTY:0, SAND:1, WATER:2, STONE:3, LAVA:4, OIL:5, FIRE:6, SMOKE:7, METAL:8, ICE:9, SEED:10, PLANT:11, WIRE:12, SPARK:13, TNT:14, PEOPLE:15, ROAD:16, LAMP:17, FARMLAND:18, PILE:19, WOOD:20, GLASS:21, ACID:22, STEAM:23, SNOW:24, BATTERY:25, HEATER:26, FAN:27, PORTAL_B:28, PORTAL_O:29, GAS:30, SOLAR:31, SENSOR:32, SPRINKLER:33 };
  const N2T = Object.fromEntries(Object.entries(T).map(([k,v]) => [v,k]));
  const C = {};
  C[T.EMPTY]=0x0a0e14; C[T.SAND]=0xE2C044; C[T.WATER]=0x3FA7D6; C[T.STONE]=0x8E9AA6; C[T.LAVA]=0xF56F3F; C[T.OIL]=0x2f2a24; C[T.FIRE]=0xFFA83A; C[T.SMOKE]=0x6e7a86; C[T.METAL]=0xB2B9C7; C[T.ICE]=0x9ED5FF; C[T.SEED]=0xA3C76D; C[T.PLANT]=0x5CC96B; C[T.WIRE]=0xCC3B3B; C[T.SPARK]=0xFFFF66; C[T.TNT]=0xD34A4A; C[T.PEOPLE]=0xF2A6B3; C[T.ROAD]=0x6b5644; C[T.LAMP]=0xE6C55A; C[T.FARMLAND]=0x4a3b2e; C[T.PILE]=0x7d6a52; C[T.WOOD]=0x7a5232; C[T.GLASS]=0xa7d7ff; C[T.ACID]=0x86f56f; C[T.STEAM]=0xbddff7; C[T.SNOW]=0xeaf6ff; C[T.BATTERY]=0xff7a7a; C[T.HEATER]=0xffaa55; C[T.FAN]=0x5aa7ff; C[T.PORTAL_B]=0x4aa8ff; C[T.PORTAL_O]=0xff9a3b; C[T.GAS]=0xa0ffc0; C[T.SOLAR]=0xfff176; C[T.SENSOR]=0x9c88ff; C[T.SPRINKLER]=0x5cd4ff;
  const SOLID = new Set([T.SAND,T.STONE,T.METAL,T.ICE,T.ROAD,T.FARMLAND,T.PILE,T.WOOD,T.GLASS,T.LAMP,T.WIRE,T.BATTERY,T.HEATER,T.FAN,T.PORTAL_B,T.PORTAL_O,T.SOLAR,T.SENSOR,T.SPRINKLER,T.TNT]);

  // === Goals toggle ===
  const GOALS_ENABLED = false;
  
  // NPC master toggle
  const NPC_ENABLED = true;
  // Portals master toggle
  const PORTALS_ENABLED = false;
function refreshGoalsUI(){
    const header = document.getElementById('goalsHeader');
    if (!header) return;
    header.textContent = GOALS_ENABLED ? 'Goals' : 'Goals (coming soon)';
    const list = document.getElementById('achList');
    if (list) list.style.display = GOALS_ENABLED ? '' : 'none';
  }

  // ===== NO COINS (removed) =====
  // - removed: COINS_ENABLED, coins, coinPill, setCoins, spend, earn, COST
  // - placement no longer checks cost

  // UI refs
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', {alpha:false});

  const $mat = document.getElementById('materialSeg');
  const $brush = document.getElementById('brush');
  const $brushOut = document.getElementById('brushOut');
  const $shape = document.getElementById('shapeSeg');
  const $erase = document.getElementById('eraseSeg');
  const $toggle = document.getElementById('toggle');
  const $step = document.getElementById('step');
  const $speed = document.getElementById('speed');
  const $zoomIn = document.getElementById('zoomIn');
  const $zoomOut = document.getElementById('zoomOut');
  const $zoomReset = document.getElementById('zoomReset');
  const $heat = document.getElementById('togHeat');
  const $day = document.getElementById('togDay');
  const $pan = document.getElementById('panMode');
  const $waterFX = document.getElementById('togWaterFX');
  const $bloom = document.getElementById('togBloom');
  const $autosave = document.getElementById('autosave');
  const $save = document.getElementById('save');
  const $load = document.getElementById('load');
  const $file = document.getElementById('file');
  const $stat = document.getElementById('stat');
  const $rolePop = document.getElementById('rolePop');
  const $brushDec = document.getElementById('brushDec');
  const $brushInc = document.getElementById('brushInc');
  const $peopleBtn = document.querySelector('label[for="m-people"]');
  const $faceB = document.getElementById('faceSegB');
  const $faceO = document.getElementById('faceSegO');
  const helpModal = document.getElementById('helpModal'); const helpBtn = document.getElementById('helpBtn');

  // World settings
  let DPI = Math.max(1, Math.min(window.devicePixelRatio||1, 2));
  let cell = 5; let W=0, H=0; // grid dims
  let grid = new Uint8Array(0);   // type
  let aux = new Uint16Array(0);   // lifetime/temperature/amount
  let updated = new Uint8Array(0);// step guard
  let activity = new Uint8Array(0);// motion heatmap

  // NPC state arrays
  let npcDir = new Uint8Array(0);     // 0=left,1=right
  let npcTask = new Uint8Array(0);    // reserved
  let npcInvStone = new Uint16Array(0);
  let npcRole = new Uint8Array(0);    // 0 builder,1 miner,2 farmer,3 firefighter
  let npcTX = new Int16Array(0), npcTY = new Int16Array(0);

  // View state
  let scale = 1; let offX = 0, offY = 0; let panning=false; let panStart=null;
  let activePointers = new Map(); let pinchStartDist=0, pinchStartScale=1;

  // Tools state
  let tool = 'sand'; let brush = 8; let shape = 'circle'; let eraseMode='all';
  let playing = true;
  let speedMul = 1; // set from slider after init
  let painting=false; let shiftDown=false;
  let spawnRole = 'random';
  let portalFaceB = 'up';
  let portalFaceO = 'up';
  const faceToDir = f => f==='up'?{dx:0,dy:-1}: f==='right'?{dx:1,dy:0}: f==='down'?{dx:0,dy:1}: {dx:-1,dy:0};
  const dirToFace = (dx,dy)=> dx===0&&dy===-1?0: dx===1&&dy===0?1: dy===1&&dx===0?2:3; // 0 up 1 right 2 down 3 left

  // Particles (visual only)
  const particles = [];
  function addParticle(x,y,color, vx,vy, ttl=40, r=0.5){ particles.push({x,y,color,vx,vy,ttl,r}); }

  // Achievements (counters only)
  const ach = { huts:0, firesOut:0, crops:0, peopleBest:0 };
  let growthCooldown = 0;

  // History (Undo/Redo)
  const hist = []; const redo = []; const MAX_HIST=20;
  function pushHistory(label){ hist.push({g:grid.slice(), a:aux.slice(), label}); if(hist.length>MAX_HIST) hist.shift(); redo.length=0; }
  function undo(){ if(!hist.length) return; const snap=hist.pop(); redo.push({g:grid.slice(), a:aux.slice(), label:'redo'}); grid.set(snap.g); aux.set(snap.a); }
  function redoAct(){ if(!redo.length) return; const snap=redo.pop(); pushHistory('undo'); grid.set(snap.g); aux.set(snap.a); }

  // Audio (tiny beeps)
  let AC=null; function initAudio(){ if(!AC){ const Ctx=window.AudioContext||window.webkitAudioContext; if(Ctx) AC=new Ctx(); } }
  function beep(freq=500, dur=0.08, type='sine', gain=0.03){ if(!AC) return; const o=AC.createOscillator(); const g=AC.createGain(); o.type=type; o.frequency.value=freq; g.gain.value=gain; o.connect(g).connect(AC.destination); o.start(); o.stop(AC.currentTime+dur); }
  function chime(){ beep(660,0.05,'sine',0.04); setTimeout(()=>beep(880,0.06,'sine',0.04),60); }
  function boom(){ beep(120,0.15,'square',0.05); setTimeout(()=>beep(60,0.2,'sawtooth',0.04),120); }
  function sizzle(){ beep(1000,0.03,'triangle',0.02); }

  // Helpers
  const idx=(x,y)=> y*W + x;
  const inb=(x,y)=> x>=0 && y>=0 && x<W && y<H;
  const clamp=(v,a,b)=> v<a?a: v>b?b: v;
  // === NPC disable helpers ===
  function purgePeople(){
    if(NPC_ENABLED) return;
    for(let i=0;i<grid.length;i++){
      if(grid[i]===T.PEOPLE){
        grid[i]=T.EMPTY; aux[i]=0;
        if(npcDir.length) npcDir[i]=0;
        if(npcTask.length) npcTask[i]=0;
        if(npcInvStone.length) npcInvStone[i]=0;
        if(npcRole.length) npcRole[i]=0;
        if(npcTX.length) npcTX[i]=0;
        if(npcTY.length) npcTY[i]=0;
      }
    }
  }
  function disableNPCsNow(){
    const pplInput=document.getElementById('m-people');
    const pplLabel=document.querySelector('label[for="m-people"]');
    if(pplInput){ pplInput.disabled=true; }
    if(pplLabel){
      pplLabel.style.opacity='.4';
      pplLabel.style.pointerEvents='none';
      pplLabel.title='People disabled for now';
    }
    const pop=document.getElementById('rolePop'); if(pop) pop.classList.remove('open');
  }
  function purgePortals(){
    if(!PORTALS_ENABLED){
      for(let i=0;i<grid.length;i++) if(grid[i]===T.PORTAL_B||grid[i]===T.PORTAL_O){ grid[i]=T.EMPTY; aux[i]=0; }
    }
  }


  // ===== Resizing logic (auto-expands world to fill box) =====
  function sizeCanvasToBox(){
    const styleW = Math.max(320, box.clientWidth|0);
    const styleH = Math.max(260, box.clientHeight|0);
    const pxW = Math.floor(styleW * DPI);
    const pxH = Math.floor(styleH * DPI);
    canvas.style.width = styleW + 'px';
    canvas.style.height = styleH + 'px';
    canvas.width = pxW;
    canvas.height = pxH;
  }
  function computeTargetWH(){
    const styleW = Math.max(320, box.clientWidth|0);
    const styleH = Math.max(260, box.clientHeight|0);
    return {
      Wt: Math.max(72, Math.floor(styleW / cell)),
      Ht: Math.max(48, Math.floor(styleH / cell))
    };
  }
  function resizeWorldTo(targetW, targetH){
    if(targetW===W && targetH===H){ sizeCanvasToBox(); return; }
    const oldW=W, oldH=H;
    const oldGrid=grid, oldAux=aux, oldNpcDir=npcDir, oldNpcTask=npcTask, oldNpcInv=npcInvStone, oldNpcRole=npcRole, oldNpcTX=npcTX, oldNpcTY=npcTY;

    W=targetW; H=targetH;
    grid=new Uint8Array(W*H);
    aux=new Uint16Array(W*H);
    updated=new Uint8Array(W*H);
    activity=new Uint8Array(W*H);
    npcDir=new Uint8Array(W*H);
    npcTask=new Uint8Array(W*H);
    npcInvStone=new Uint16Array(W*H);
    npcRole=new Uint8Array(W*H);
    npcTX=new Int16Array(W*H);
    npcTY=new Int16Array(W*H);

    // Copy old content; align top-left and push down if growing
    const yOffset = Math.max(0, H - oldH);
    const copyH = Math.min(oldH, H);
    const copyW = Math.min(oldW, W);
    for(let y=0; y<copyH; y++){
      const srcY = y;
      const dstY = y + yOffset;
      for(let x=0; x<copyW; x++){
        const s = srcY*oldW + x;
        const d = dstY*W + x;
        grid[d] = oldGrid[s];
        aux[d] = oldAux[s];
        npcDir[d] = oldNpcDir[s];
        npcTask[d] = oldNpcTask[s];
        npcInvStone[d] = oldNpcInv[s];
        npcRole[d] = oldNpcRole[s];
        npcTX[d] = oldNpcTX[s];
        npcTY[d] = oldNpcTY[s];
      }
    }
    for(let x=0;x<W;x++) grid[(H-1)*W + x] = T.STONE; // ground
    sizeCanvasToBox();
    updateStats();
  }
  function initSizing(){
    const {Wt,Ht} = computeTargetWH();
    W=Wt; H=Ht;
    grid=new Uint8Array(W*H);
    aux=new Uint16Array(W*H);
    updated=new Uint8Array(W*H);
    activity=new Uint8Array(W*H);
    npcDir=new Uint8Array(W*H);
    npcTask=new Uint8Array(W*H);
    npcInvStone=new Uint16Array(W*H);
    npcRole=new Uint8Array(W*H);
    npcTX=new Int16Array(W*H);
    npcTY=new Int16Array(W*H);
    for(let x=0;x<W;x++) grid[idx(x,H-1)]=T.STONE; // ground
    sizeCanvasToBox();
    updateStats();
  }

  const box = document.querySelector('.canvas-box');

  const ro = new ResizeObserver(()=>{
    DPI=Math.max(1, Math.min(window.devicePixelRatio||1, 2));
    const {Wt,Ht} = computeTargetWH();
    resizeWorldTo(Wt, Ht);
  });
  ro.observe(box);
  window.addEventListener('resize', ()=>{
    DPI=Math.max(1, Math.min(window.devicePixelRatio||1, 2));
    const {Wt,Ht} = computeTargetWH();
    resizeWorldTo(Wt, Ht);
  }, {passive:true});

  // ===== Painting =====
  function viewToGrid(ev){
    const rect=canvas.getBoundingClientRect();
    const px=(ev.clientX-rect.left)*(canvas.width/rect.width);
    const py=(ev.clientY-rect.top)*(canvas.height/rect.height);
    const wx=(px - offX)/(DPI*cell*scale);
    const wy=(py - offY)/(DPI*cell*scale);
    return {x:Math.floor(wx), y:Math.floor(wy)};
  }
  function stampAt(gx,gy){
    const r=Math.max(1, Math.floor(brush/cell));
    if(shape==='spray'){
      for(let i=0;i<r*8;i++){
        const a=Math.random()*Math.PI*2;
        const d=Math.random()*r;
        placeAt(gx+Math.round(Math.cos(a)*d), gy+Math.round(Math.sin(a)*d));
      }
      return;
    }
    for(let y=-r;y<=r;y++){
      for(let x=-r;x<=r;x++){
        if(shape==='circle' && (x*x+y*y>r*r)) continue;
        placeAt(gx+x, gy+y);
      }
    }
  }
  function placeAt(x,y){
    if(!inb(x,y)) return;
    const i=idx(x,y);
    if(tool==='people' && typeof NPC_ENABLED!=='undefined' && !NPC_ENABLED){ return; }
    if(tool==='air'){ return; }
    if(tool==='erase'){
      // Erase behavior (all or current type)
      if(eraseMode==='all'){ grid[i]=T.EMPTY; aux[i]=0; }
      else {
        const t=nameToType(tool);
        if(grid[i]===t){ grid[i]=T.EMPTY; aux[i]=0; }
        else { grid[i]=T.EMPTY; aux[i]=0; } // fallback to full erase
      }
      return;
    }

    // NO coin spending — always place
    const t=nameToType(tool);
    if(!PORTALS_ENABLED && (t===T.PORTAL_B || t===T.PORTAL_O)) return; // portals disabled
    grid[i]=t;
    if(t===T.FIRE) aux[i]=8+Math.floor(Math.random()*8);
    if(t===T.SMOKE) aux[i]=10+Math.floor(Math.random()*20);
    if(t===T.GAS) aux[i]=10+Math.floor(Math.random()*18);
    if(t===T.STEAM) aux[i]=10+Math.floor(Math.random()*18);
    if(t===T.LAMP) aux[i]=0; // power level
    if(t===T.BATTERY) aux[i]=Math.floor(Math.random()*16); // phase offset
    if(PORTALS_ENABLED){
      if(t===T.PORTAL_B){ const f=faceToDir(portalFaceB); aux[i]=dirToFace(f.dx,f.dy); }
      if(t===T.PORTAL_O){ const f=faceToDir(portalFaceO); aux[i]=dirToFace(f.dx,f.dy); }
    }
    if(t===T.SPARK) aux[i]=3;
    if(t===T.TNT) aux[i]=0;
    if(t===T.PEOPLE){
      npcDir[i]=Math.random()<0.5?0:1;
      npcTask[i]=0;
      npcInvStone[i]=20+Math.floor(Math.random()*40);
      npcRole[i]=roleToId(spawnRole);
      npcTX[i]=-1; npcTY[i]=-1;
    }
  }
  function nameToType(n){ switch(n){
    case 'sand':return T.SAND; case 'water':return T.WATER; case 'stone':return T.STONE;
    case 'lava':return T.LAVA; case 'oil':return T.OIL; case 'fire':return T.FIRE;
    case 'smoke':return T.SMOKE; case 'steam':return T.STEAM; case 'metal':return T.METAL; case 'ice':return T.ICE;
    case 'seed':return T.SEED; case 'plant':return T.PLANT; case 'wire':return T.WIRE;
    case 'spark':return T.SPARK; case 'tnt':return T.TNT; case 'people':return T.PEOPLE;
    case 'road':return T.ROAD; case 'lamp':return T.LAMP; case 'farmland':return T.FARMLAND;
    case 'pile':return T.PILE; case 'wood':return T.WOOD; case 'glass':return T.GLASS;
    case 'acid':return T.ACID; case 'snow':return T.SNOW; case 'battery':return T.BATTERY;
    case 'heater':return T.HEATER; case 'fan':return T.FAN; case 'portalB':return PORTALS_ENABLED?T.PORTAL_B:T.EMPTY; case 'portalO':return PORTALS_ENABLED?T.PORTAL_O:T.EMPTY;
    case 'gas':return T.GAS; case 'solar':return T.SOLAR; case 'sensor':return T.SENSOR; case 'sprinkler':return T.SPRINKLER; default:return T.EMPTY;
  } }
  function roleToId(r){ return r==='builder'?0 : r==='miner'?1 : r==='farmer'?2 : r==='firefighter'?3 : Math.floor(Math.random()*4); }

  // ===== Simulation helpers =====
  function swap(i,j){
    const t=grid[i]; grid[i]=grid[j]; grid[j]=t;
    const a=aux[i]; aux[i]=aux[j]; aux[j]=a;
    updated[j]=1; activity[j]=Math.min(255, activity[j]+20);
  }
  function movePerson(i,j){
    // swap including NPC state
    const t=grid[i]; grid[i]=grid[j]; grid[j]=t;
    const a=aux[i]; aux[i]=aux[j]; aux[j]=a;
    const d=npcDir[i]; npcDir[i]=npcDir[j]; npcDir[j]=d;
    const task=npcTask[i]; npcTask[i]=npcTask[j]; npcTask[j]=task;
    const inv=npcInvStone[i]; npcInvStone[i]=npcInvStone[j]; npcInvStone[j]=inv;
    const role=npcRole[i]; npcRole[i]=npcRole[j]; npcRole[j]=role;
    const tx=npcTX[i], ty=npcTY[i]; npcTX[i]=npcTX[j]; npcTX[j]=tx; npcTY[i]=npcTY[j]; npcTY[j]=ty;
    updated[j]=1; activity[j]=Math.min(255, activity[j]+20);
  }

  function igniteNeighbors(x,y){
    const dirs=[[1,0],[-1,0],[0,1],[0,-1]];
    for(const [dx,dy] of dirs){
      const nx=x+dx, ny=y+dy; if(!inb(nx,ny)) continue; const j=idx(nx,ny); const t=grid[j];
      if(t===T.OIL||t===T.PLANT||t===T.SEED||t===T.WOOD){ grid[j]=T.FIRE; aux[j]=8+Math.floor(Math.random()*8); }
      if(t===T.TNT && aux[j]===0){ aux[j]=8; }
      if(t===T.ICE){ grid[j]=T.WATER; }
    }
  }
  function spreadTo(x,y,targets,newT,prob){
    const dirs=[[1,0],[-1,0],[0,1],[0,-1]];
    for(const [dx,dy] of dirs){
      if(Math.random()>prob) continue;
      const nx=x+dx, ny=y+dy; if(!inb(nx,ny)) continue; const j=idx(nx,ny);
      if(targets.includes(grid[j])){ grid[j]=newT; aux[j]=8+Math.floor(Math.random()*8); }
    }
  }
  function setNeighbors(x,y,findT,setT){
    const dirs=[[1,0],[-1,0],[0,1],[0,-1]];
    for(const [dx,dy] of dirs){
      const nx=x+dx, ny=y+dy; if(!inb(nx,ny)) continue; const j=idx(nx,ny);
      if(grid[j]===findT){ grid[j]=setT; aux[j]=0; }
    }
  }
  function explode(cx,cy,r){
    const r2=r*r;
    for(let y=-r;y<=r;y++){
      for(let x=-r;x<=r;x++){
        if(x*x+y*y>r2) continue;
        const gx=cx+x, gy=cy+y; if(!inb(gx,gy)) continue; const i=idx(gx,gy);
        if(grid[i]===T.METAL) continue;
        if(Math.hypot(x,y)>r-1 && grid[i]!==T.EMPTY){ grid[i]=T.FIRE; aux[i]=6+Math.floor(Math.random()*6); }
        else { grid[i]=T.EMPTY; aux[i]=0; }
        activity[i]=200;
      }
    }
    boom();
  }
  function adjAny(x,y,arr){
    const dirs=[[1,0],[-1,0],[0,1],[0,-1]];
    for(const [dx,dy] of dirs){
      const nx=x+dx, ny=y+dy;
      if(nx<0||ny<0||nx>=W||ny>=H) continue;
      if(arr.includes(grid[idx(nx,ny)])) return true;
    }
    return false;
  }

  // ===== MAIN STEP =====
  function step(){
    updated.fill(0);

    // Materials bottom-up
    for(let y=H-2; y>=0; y--){
      const leftFirst = Math.random()<0.5;
      for(let xx=0; xx<W; xx++){
        const x = leftFirst? xx : (W-1-xx);
        const i=idx(x,y); const t=grid[i];
        if(t===T.EMPTY||updated[i]) continue;
        const ib=idx(x,y+1);
        const below=inb(x,y+1)?grid[ib]:T.STONE;

        switch(t){
          case T.SAND: {
            if(below===T.EMPTY||below===T.WATER||below===T.OIL||below===T.SMOKE) { swap(i,ib); break; }
            const dirs=Math.random()<0.5?[-1,1]:[1,-1];
            let moved=false;
            for(const d of dirs){
              const nx=x+d, ny=y+1; if(!inb(nx,ny)) continue; const j=idx(nx,ny); const bt=grid[j];
              if(bt===T.EMPTY||bt===T.WATER||bt===T.OIL||bt===T.SMOKE){ swap(i, j); moved=true; break; }
            }
            // Glass forging near heat
            if(!moved && (adjAny(x,y,[T.FIRE,T.LAVA])) && Math.random()<0.02){ grid[i]=T.GLASS; aux[i]=0; break; }
            if(!moved) updated[i]=1; break;
          }
          case T.WATER: {
            if(below===T.EMPTY){ swap(i,ib); break; }
            const dirs=Math.random()<0.5?[-1,1]:[1,-1];
            let moved=false;
            for(const d of dirs){
              const sx=x+d;
              if(inb(sx,y) && grid[idx(sx,y)]===T.EMPTY){ swap(i, idx(sx,y)); moved=true; break; }
            }
            if(!moved){
              for(const d of dirs){
                const nx=x+d, ny=y+1;
                if(inb(nx,ny) && grid[idx(nx,ny)]===T.EMPTY){ swap(i, idx(nx,ny)); moved=true; break; }
              }
            }
            if(adjAny(x,y,[T.LAVA])){ grid[i]=T.STEAM; aux[i]=10+Math.floor(Math.random()*12); setNeighbors(x,y,T.LAVA, T.STONE); }
            if(adjAny(x,y,[T.FIRE])){ grid[i]=T.STEAM; aux[i]=8+Math.floor(Math.random()*8); }
            updated[i]=1; break;
          }
          case T.OIL: {
            if(below===T.EMPTY){ swap(i,ib); break; }
            const dirs=Math.random()<0.5?[-1,1]:[1,-1];
            let moved=false;
            for(const d of dirs){
              const sx=x+d;
              if(inb(sx,y) && grid[idx(sx,y)]===T.EMPTY){ swap(i, idx(sx,y)); moved=true; break; }
            }
            if(!moved){
              for(const d of dirs){
                const nx=x+d, ny=y+1;
                if(inb(nx,ny) && grid[idx(nx,ny)]===T.EMPTY){ swap(i, idx(nx,ny)); moved=true; break; }
              }
            }
            if(adjAny(x,y,[T.FIRE,T.LAVA,T.SPARK])){ grid[i]=T.FIRE; aux[i]=10+Math.floor(Math.random()*10); }
            updated[i]=1; break;
          }
          case T.LAVA: {
            if((aux[i]&1)===0){ if(below===T.EMPTY){ swap(i,ib); break; } }
            const dirs=Math.random()<0.5?[-1,1]:[1,-1];
            let moved=false;
            for(const d of dirs){
              const sx=x+d;
              if(inb(sx,y) && grid[idx(sx,y)]===T.EMPTY){ swap(i, idx(sx,y)); moved=true; break; }
            }
            if(!moved){
              for(const d of dirs){
                const nx=x+d, ny=y+1;
                if(inb(nx,ny) && grid[idx(nx,ny)]===T.EMPTY){ swap(i, idx(nx,ny)); moved=true; break; }
              }
            }
            if(adjAny(x,y,[T.WATER,T.ICE]) || Math.random()<0.01){ grid[i]=T.STONE; aux[i]=0; break; }
            igniteNeighbors(x,y);
            aux[i]=(aux[i]+1)&3;
            if(Math.random()<0.03){ addParticle(x+Math.random()*0.6, y+Math.random()*0.6, 0xFF7733, (Math.random()-0.5)*0.02, -0.03-Math.random()*0.02, 40, 0.5); }
            updated[i]=1; break;
          }
          case T.ICE: {
            if(adjAny(x,y,[T.LAVA,T.FIRE])){ grid[i]=T.WATER; break; }
            updated[i]=1; break;
          }
          case T.WOOD: {
            // Static, flammable
            if(adjAny(x,y,[T.FIRE,T.LAVA,T.SPARK])){ grid[i]=T.FIRE; aux[i]=6+Math.floor(Math.random()*6); }
            updated[i]=1; break;
          }
          case T.GLASS: {
            // Inert solid
            updated[i]=1; break;
          }
          case T.ACID: {
            // Liquid similar to water, dissolves many materials
            if(below===T.EMPTY){ swap(i,ib); break; }
            const dirsA=Math.random()<0.5?[-1,1]:[1,-1];
            let movedA=false;
            for(const d of dirsA){
              const sx=x+d;
              if(inb(sx,y) && grid[idx(sx,y)]===T.EMPTY){ swap(i, idx(sx,y)); movedA=true; break; }
            }
            if(!movedA){
              for(const d of dirsA){
                const nx=x+d, ny=y+1;
                if(inb(nx,ny) && grid[idx(nx,ny)]===T.EMPTY){ swap(i, idx(nx,ny)); movedA=true; break; }
              }
            }
            // Reactivity
            const targets=[T.STONE,T.METAL,T.PLANT,T.SEED,T.ICE,T.WIRE,T.TNT,T.PILE];
            const dirsR=[[1,0],[-1,0],[0,1],[0,-1]];
            for(const [dx,dy] of dirsR){
              const nx=x+dx, ny=y+dy; if(!inb(nx,ny)) continue; const j=idx(nx,ny);
              if(targets.includes(grid[j]) && Math.random()<0.35){
                // dissolve target; emit a puff and sometimes neutralize to water
                grid[j]=T.SMOKE; aux[j]=6+Math.floor(Math.random()*6);
                if(Math.random()<0.25){ grid[i]=T.WATER; }
              }
              if(grid[j]===T.WATER && Math.random()<0.15){ grid[i]=T.WATER; }
            }
            updated[i]=1; break;
          }
          case T.STEAM: {
            // Rises, then condenses to water
            if(aux[i]===0){
              // try condense downward if empty below
              if(inb(x,y+1) && grid[idx(x,y+1)]===T.EMPTY){ grid[idx(x,y+1)]=T.WATER; grid[i]=T.EMPTY; aux[idx(x,y+1)]=0; break; }
              grid[i]=T.WATER; break;
            }
            aux[i]--;
            if(Math.random()<0.05){ addParticle(x+Math.random()*0.6, y+Math.random()*0.4, 0xFFAA55, (Math.random()-0.5)*0.03, -0.05-Math.random()*0.03, 35, 0.45); }
            if(inb(x,y-1) && grid[idx(x,y-1)]===T.EMPTY){ swap(i, idx(x,y-1)); break; }
            const dirsS=Math.random()<0.5?[-1,1]:[1,-1];
            for(const d of dirsS){
              const nx=x+d;
              if(inb(nx,y-1) && grid[idx(nx,y-1)]===T.EMPTY){ swap(i, idx(nx,y-1)); break; }
            }
            updated[i]=1; break;
          }
          case T.SNOW: {
            // Powder similar to sand, melts near heat
            if(below===T.EMPTY||below===T.WATER||below===T.OIL||below===T.SMOKE) { swap(i,ib); break; }
            const dirsN=Math.random()<0.5?[-1,1]:[1,-1];
            let movedN=false;
            for(const d of dirsN){
              const nx=x+d, ny=y+1; if(!inb(nx,ny)) continue; const j=idx(nx,ny); const bt=grid[j];
              if(bt===T.EMPTY||bt===T.WATER||bt===T.OIL||bt===T.SMOKE){ swap(i, j); movedN=true; break; }
            }
            if(adjAny(x,y,[T.FIRE,T.LAVA])){ grid[i]=T.WATER; break; }
            if(!movedN){ updated[i]=1; }
            break;
          }
          case T.METAL:
          case T.STONE:
          case T.WIRE:
          case T.TNT:
          case T.ROAD:
          case T.FARMLAND:
          case T.PILE:
          case T.PORTAL_B:
          case T.PORTAL_O: { updated[i]=1; break; }

          case T.LAMP: {
            // Power decay; brighten when powered by spark next to it
            if(aux[i]>0) aux[i]--;
            if(adjAny(x,y,[T.SPARK])){ aux[i]=6; }
            updated[i]=1; break;
          }
          
          case T.SEED: {
            if(adjAny(x,y,[T.WATER]) && (below!==T.EMPTY)){ grid[i]=T.PLANT; aux[i]=20+Math.floor(Math.random()*40); }
            if(below===T.EMPTY){ swap(i,ib); break; }
            updated[i]=1; break;
          }
          case T.PLANT: {
            if(adjAny(x,y,[T.FIRE,T.LAVA])){ grid[i]=T.FIRE; aux[i]=6+Math.floor(Math.random()*6); break; }
            if(aux[i]>0){
              aux[i]--;
              if(inb(x,y-1) && grid[idx(x,y-1)]===T.EMPTY && Math.random()<0.05){
                grid[idx(x,y-1)]=T.PLANT; aux[idx(x,y-1)]=10;
              }
            }
            updated[i]=1; break;
          }
          case T.FIRE: {
            if(aux[i]===0){ grid[i]=T.SMOKE; aux[i]=8+Math.floor(Math.random()*10); break; }
            aux[i]--;
            spreadTo(x,y,[T.OIL,T.PLANT,T.SEED], T.FIRE, 0.5);
            if(adjAny(x,y,[T.WATER, T.ICE])){ grid[i]=T.SMOKE; aux[i]=6+Math.floor(Math.random()*6); break; }
            updated[i]=1; break;
          }
          case T.SMOKE: {
            if(aux[i]===0){ grid[i]=T.EMPTY; break; }
            aux[i]--;
            if(inb(x,y-1) && grid[idx(x,y-1)]===T.EMPTY){ swap(i, idx(x,y-1)); break; }
            const dirs=Math.random()<0.5?[-1,1]:[1,-1];
            for(const d of dirs){
              const nx=x+d;
              if(inb(nx,y-1) && grid[idx(nx,y-1)]===T.EMPTY){ swap(i, idx(nx,y-1)); break; }
            }
            updated[i]=1; break;
          }
          case T.GAS: {
            if(aux[i]===0){ grid[i]=T.EMPTY; break; }
            aux[i]--;
            // ignite if near flame/spark/lava
            if(adjAny(x,y,[T.FIRE,T.LAVA,T.SPARK])){ grid[i]=T.FIRE; aux[i]=6+Math.floor(Math.random()*8); break; }
            if(inb(x,y-1) && grid[idx(x,y-1)]===T.EMPTY){ swap(i, idx(x,y-1)); break; }
            const dirsG=Math.random()<0.5?[-1,1]:[1,-1];
            for(const d of dirsG){ const nx=x+d; if(inb(nx,y-1) && grid[idx(nx,y-1)]===T.EMPTY){ swap(i, idx(nx,y-1)); break; } }
            updated[i]=1; break;
          }
          case T.SPARK: {
            if(aux[i]===0){ grid[i]=T.EMPTY; break; }
            aux[i]--;
            igniteNeighbors(x,y);
            const dirs2=[[1,0],[-1,0],[0,1],[0,-1]];
            for(const [dx,dy] of dirs2){
              const nx=x+dx, ny=y+dy; if(!inb(nx,ny)) continue; const j=idx(nx,ny);
              if(grid[j]===T.WIRE){ grid[j]=T.SPARK; aux[j]=2; }
            }
            updated[i]=1; break;
          }
          case T.BATTERY: {
            // Periodically emit spark into adjacent wires
            aux[i] = (aux[i]+1)&31; // 0..31
            if((aux[i]&7)===0){
              const dirsB=[[1,0],[-1,0],[0,1],[0,-1]];
              for(const [dx,dy] of dirsB){
                const nx=x+dx, ny=y+dy; if(!inb(nx,ny)) continue; const j=idx(nx,ny);
                if(grid[j]===T.WIRE){ grid[j]=T.SPARK; aux[j]=3; }
              }
            }
            updated[i]=1; break;
          }
          case T.HEATER: {
            // Heat nearby materials
            const dirsH=[[1,0],[-1,0],[0,1],[0,-1]];
            for(const [dx,dy] of dirsH){
              const nx=x+dx, ny=y+dy; if(!inb(nx,ny)) continue; const j=idx(nx,ny);
              const t2=grid[j];
              if(t2===T.WATER){ grid[j]=T.STEAM; aux[j]=10+Math.floor(Math.random()*10); }
              if(t2===T.ICE||t2===T.SNOW){ grid[j]=T.WATER; aux[j]=0; }
              if(t2===T.WOOD||t2===T.PLANT||t2===T.SEED||t2===T.OIL){ grid[j]=T.FIRE; aux[j]=6+Math.floor(Math.random()*6); }
            }
            updated[i]=1; break;
          }
          case T.FAN: {
            // Push light gases upward
            const upx=x, upy=y-1;
            if(inb(upx,upy)){
              const j=idx(upx,upy);
              const t2=grid[j];
              if((t2===T.SMOKE||t2===T.STEAM||t2===T.FIRE) && inb(upx,upy-1) && grid[idx(upx,upy-1)]===T.EMPTY){
                swap(j, idx(upx,upy-1));
              } else {
                // nudge sideways if blocked
                const dir = Math.random()<0.5? -1:1;
                const sx=x+dir, sy=y-1; if(inb(sx,sy) && (grid[idx(sx,sy)]===T.EMPTY)) swap(idx(upx,upy), idx(sx,sy));
              }
            }
            updated[i]=1; break;
          }
          case T.SOLAR: {
            // daytime pulsing
            aux[i]=(aux[i]+1)&31;
            if($day.checked && (aux[i]&1)===0){
              const dirsH=[[1,0],[-1,0],[0,1],[0,-1]];
              for(const [dx,dy] of dirsH){ const nx=x+dx, ny=y+dy; if(!inb(nx,ny)) continue; const j=idx(nx,ny); if(grid[j]===T.WIRE){ grid[j]=T.SPARK; aux[j]=2; } }
            }
            updated[i]=1; break;
          }
          case T.SENSOR: {
            // Trigger when detects person or fire
            if(adjAny(x,y,[T.PEOPLE,T.FIRE])){
              const dirsH=[[1,0],[-1,0],[0,1],[0,-1]];
              for(const [dx,dy] of dirsH){ const nx=x+dx, ny=y+dy; if(!inb(nx,ny)) continue; const j=idx(nx,ny); if(grid[j]===T.WIRE){ grid[j]=T.SPARK; aux[j]=2; } }
            }
            updated[i]=1; break;
          }
          case T.SPRINKLER: {
            // If powered, emit water above else sides
            if(adjAny(x,y,[T.SPARK])){
              const order=[[0,-1],[1,0],[-1,0],[0,1]];
              for(const [dx,dy] of order){ const nx=x+dx, ny=y+dy; if(!inb(nx,ny)) continue; const j=idx(nx,ny); if(grid[j]===T.EMPTY){ grid[j]=T.WATER; aux[j]=0; break; } }
            }
            updated[i]=1; break;
          }
          case T.PEOPLE: {
            // Basic gravity and walking
            const belowT = below;
            const idir = npcDir[i];
            // Avoid hazards
            if(adjAny(x,y,[T.FIRE,T.LAVA])){
              const away = idir===0?1:-1; // try move away
              if(inb(x+away,y) && grid[idx(x+away,y)]===T.EMPTY){ movePerson(i, idx(x+away,y)); npcDir[idx(x+away,y)]=away===-1?0:1; break; }
            }
            // Fall
            if(belowT===T.EMPTY){ movePerson(i,ib); break; }
            // Slide on slopes
            const order = Math.random()<0.5?[ -1,1 ]:[ 1,-1 ];
            let slid=false;
            for(const d of order){
              const nx=x+d, ny=y+1; if(!inb(nx,ny)) continue; const j=idx(nx,ny);
              if(grid[j]===T.EMPTY){ movePerson(i,j); slid=true; npcDir[j]=(d<0?0:1); break; }
            }
            if(slid) break;
            // Walk
            const stepDir = (idir===0?-1:1);
            if(Math.random()<0.7){
              const nx=x+stepDir; if(inb(nx,y) && grid[idx(nx,y)]===T.EMPTY){ movePerson(i, idx(nx,y)); break; } else { npcDir[i]=idir?0:1; }
            }

            // Role actions
            const role = npcRole[i];
            const dirsN=[[1,0],[-1,0],[0,1],[0,-1]];
            if(role===3){ // Firefighter
              for(const [dx,dy] of dirsN){ const nx=x+dx, ny=y+dy; if(!inb(nx,ny)) continue; const j=idx(nx,ny); if(grid[j]===T.FIRE){ grid[j]=T.SMOKE; aux[j]=8; sizzle(); }}
            } else if(role===1){ // Miner
              for(const [dx,dy] of dirsN){ const nx=x+dx, ny=y+dy; if(!inb(nx,ny)) continue; const j=idx(nx,ny); if(grid[j]===T.STONE && Math.random()<0.1){ grid[j]=T.PILE; aux[j]=0; }}
            } else if(role===0){ // Builder
              // Pickup piles
              for(const [dx,dy] of dirsN){ const nx=x+dx, ny=y+dy; if(!inb(nx,ny)) continue; const j=idx(nx,ny); if(grid[j]===T.PILE){ grid[j]=T.EMPTY; npcInvStone[i]+=5; }}
              // Place stone above road
              if(npcInvStone[i]>0){
                // If standing on road and cell above empty
                if(inb(x,y+1) && grid[idx(x,y+1)]===T.ROAD && inb(x,y-1) && grid[idx(x,y-1)]===T.EMPTY){
                  grid[idx(x,y-1)]=T.STONE; npcInvStone[i]--; npcTask[i] = (npcTask[i]+1)|0; if(npcTask[i]%6===0) ach.huts++;
                } else {
                  // Try adjacent road
                  for(const [dx,dy] of dirsN){ const nx=x+dx, ny=y+dy; if(!inb(nx,ny)) continue; const j=idx(nx,ny); if(grid[j]===T.ROAD){ const above=idx(nx,ny-1); if(inb(nx,ny-1) && grid[above]===T.EMPTY){ grid[above]=T.STONE; npcInvStone[i]--; npcTask[i] = (npcTask[i]+1)|0; if(npcTask[i]%6===0) ach.huts++; break; } }
                  }
                }
              }
            } else if(role===2){ // Farmer
              for(const [dx,dy] of dirsN){
                const nx=x+dx, ny=y+dy; if(!inb(nx,ny)) continue; const j=idx(nx,ny);
                if(grid[j]===T.SAND && adjAny(nx,ny,[T.WATER]) && Math.random()<0.2){
                  grid[j]=T.FARMLAND; if(inb(nx,ny-1) && grid[idx(nx,ny-1)]===T.EMPTY) { grid[idx(nx,ny-1)]=T.PLANT; aux[idx(nx,ny-1)]=10; }
                }
              }
            }
            updated[i]=1; break;
          }
        }
      }
    }

    // Very light population growth
    if(growthCooldown>0) growthCooldown--;
    else {
      const huts=ach.huts; let ppl=0;
      for(let i=0;i<grid.length;i++) if(grid[i]===T.PEOPLE) ppl++;
      if(huts>0 && ppl < huts*2){
        for(let tries=0; tries<200; tries++){
          const x=~~(Math.random()*W), y=~~(Math.random()*(H-2));
          if(grid[idx(x,y)]===T.ROAD && grid[idx(x,y-1)]===T.EMPTY){
            grid[idx(x,y-1)]=T.PEOPLE; npcRole[idx(x,y-1)]=Math.floor(Math.random()*4);
            npcInvStone[idx(x,y-1)]=10+~~(Math.random()*20);
            ach.peopleBest=Math.max(ach.peopleBest, ppl+1);
            growthCooldown=900; break;
          }
        }
      }
    }

    // Portals disabled
    // processPortals();

    // particles update (visual only)
    for(let p=particles.length-1; p>=0; p--){
      const P=particles[p]; P.ttl--; P.x+=P.vx; P.y+=P.vy; P.vy+=0.001; if(P.ttl<=0) particles.splice(p,1);
    }
  }

  function processPortals(){
    // collect blue and orange portals
    const blues=[], oranges=[];
    for(let y=0;y<H;y++) for(let x=0;x<W;x++){
      const t=grid[idx(x,y)]; if(t===T.PORTAL_B) blues.push({x,y}); else if(t===T.PORTAL_O) oranges.push({x,y});
    }
    if(blues.length===0 || oranges.length===0) return;
    const immovables = new Set([T.EMPTY,T.METAL,T.STONE,T.GLASS,T.WIRE,T.TNT,T.ROAD,T.LAMP,T.FARMLAND,T.WOOD,T.BATTERY,T.HEATER,T.FAN,T.PORTAL_B,T.PORTAL_O,T.SOLAR,T.SENSOR,T.SPRINKLER]);

    const handleSide = (portalsFrom, portalsTo) => {
      for(const p of portalsFrom){
        const dirs=[[0,1],[0,-1],[1,0],[-1,0]]; // check neighbors
        for(const [dx,dy] of dirs){
          const sx=p.x+dx, sy=p.y+dy; if(!inb(sx,sy)) continue; const si=idx(sx,sy); const t=grid[si];
          if(immovables.has(t)) continue;
          // pick nearest target portal
          let best=null, bestd=1e9;
          for(const q of portalsTo){ const d2=(q.x-p.x)*(q.x-p.x)+(q.y-p.y)*(q.y-p.y); if(d2<bestd){ best=q; bestd=d2; } }
          if(!best) continue;
          // exit uses target portal's facing from aux
          const fcode = aux[idx(best.x,best.y)]&3;
          const faceDirs = [[0,-1],[1,0],[0,1],[-1,0]]; // 0 up,1 right,2 down,3 left
          const primary = faceDirs[fcode] || [0,-1];
          const candidates=[primary, [0,-1],[1,0],[-1,0],[0,1]]; // prefer face, else any side
          for(const [ex,ey] of candidates){
            const tx=best.x+ex, ty=best.y+ey; if(!inb(tx,ty)) continue; const ti=idx(tx,ty);
            if(grid[ti]!==T.EMPTY) continue;
            if(t===T.PEOPLE){
              grid[ti]=t; aux[ti]=aux[si]; grid[si]=T.EMPTY; aux[si]=0;
              npcDir[ti]=npcDir[si]; npcTask[ti]=npcTask[si]; npcInvStone[ti]=npcInvStone[si]; npcRole[ti]=npcRole[si]; npcTX[ti]=npcTX[si]; npcTY[ti]=npcTY[si];
              npcDir[si]=0; npcTask[si]=0; npcInvStone[si]=0; npcRole[si]=0; npcTX[si]=0; npcTY[si]=0;
            } else {
              grid[ti]=t; aux[ti]=aux[si]; grid[si]=T.EMPTY; aux[si]=0;
            }
            updated[ti]=1; activity[ti]=200; break;
          }
        }
      }
    };
    handleSide(blues, oranges);
    handleSide(oranges, blues);
  }

  // ===== Rendering =====
  let buf = null, bctx = null;
  let glow = null, gctx = null;
  // WebGL post FX (water + bloom)
  let wglCanvas=null, wgl=null, wglProg=null, wglBuf=null, wglPosLoc=-1, wglSceneTex=null, wglMaskTex=null, wglTimeLoc=null, wglResLoc=null, wglSceneLoc=null, wglMaskLoc=null;
  let wglBloomProg=null, wglBloomPosLoc=-1, wglBloomResLoc=null, wglBloomSceneLoc=null, wglBloomTimeLoc=null;
  let waterMaskArr=null;
  const img = () => new ImageData(W,H);
  let frame=null; let tDay=0;
  const USE_GL_WORLD = true; // fallback/default
  const USE_WGPU_WORLD = false; // WebGPU disabled for now
  // GL world renderer
  let glWorldCanvas=null, glWorld=null, glWorldProg=null, glWorldBuf=null, glWorldPosLoc=-1;
  let glWorldDataTex=null, glWorldPalTex=null;
  let glWorldResLoc=null, glWorldTimeLoc=null, glWorldDataLoc=null, glWorldPalLoc=null;
  let worldDataArr=null, worldPalArr=null;
  let sceneSource=null; // canvas used as scene texture for post FX

  // WebGPU world renderer
  let wgpuReady=false, wgpuError=null;
  let wgpuCanvas=null, wgpuCtx=null, wgpuDevice=null, wgpuFormat=null;
  let wgpuWorldTex=null, wgpuPalTex=null, wgpuSampler=null, wgpuPipeline=null;
  let wgpuBindLayout=null, wgpuBindGroup=null, wgpuVertexBuf=null, wgpuUniformBuf=null;
  let wgpuWorldRowPitch=0, wgpuWorldUpload=null;

  async function initWorldWGPU(){
    try{
      if(!('gpu' in navigator)) { wgpuReady=false; return; }
      const adapter = await navigator.gpu.requestAdapter(); if(!adapter){ wgpuReady=false; return; }
      wgpuDevice = await adapter.requestDevice();
      // canvas for wgpu world
      wgpuCanvas = document.createElement('canvas'); wgpuCanvas.width=W; wgpuCanvas.height=H;
      wgpuCtx = wgpuCanvas.getContext('webgpu');
      wgpuFormat = navigator.gpu.getPreferredCanvasFormat();
      wgpuCtx.configure({ device: wgpuDevice, format: wgpuFormat, alphaMode:'premultiplied' });
      // mount behind the 2D canvas for overlays
      const parent = canvas.parentElement; if(parent && !wgpuCanvas.isConnected){
        wgpuCanvas.style.position='absolute'; wgpuCanvas.style.left='0'; wgpuCanvas.style.top='0';
        wgpuCanvas.style.imageRendering='pixelated'; wgpuCanvas.style.pointerEvents='none';
        parent.style.position='relative'; parent.insertBefore(wgpuCanvas, canvas); // place behind 2D canvas
      }
      // resources
      const makeTex = (w,h,usage) => wgpuDevice.createTexture({ size:{width:w,height:h}, format:'rgba8unorm', usage });
      wgpuWorldTex = makeTex(W,H, GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST);
      wgpuPalTex = makeTex(256,1, GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST);
      wgpuSampler = wgpuDevice.createSampler({ magFilter:'nearest', minFilter:'nearest', addressModeU:'clamp-to-edge', addressModeV:'clamp-to-edge' });
      // upload palette
      if(!worldPalArr){ worldPalArr=new Uint8Array(256*4); for(let i=0;i<256;i++){ let hex=C[i]??0; const o=i*4; worldPalArr[o]=(hex>>16)&255; worldPalArr[o+1]=(hex>>8)&255; worldPalArr[o+2]=hex&255; worldPalArr[o+3]=255; } }
      wgpuDevice.queue.writeTexture(
        { texture: wgpuPalTex },
        worldPalArr, { bytesPerRow: 256*4 }, { width:256, height:1 }
      );
      // uniforms (vec2 + time + waterOn + bloom + padding)
      wgpuUniformBuf = wgpuDevice.createBuffer({ size: 32, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });
      // quad
      wgpuVertexBuf = wgpuDevice.createBuffer({ size: 16*4, usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST });
      const quad=new Float32Array([-1,-1, 1,-1, -1,1, 1,1]); wgpuDevice.queue.writeBuffer(wgpuVertexBuf, 0, quad);
      // pipeline
      const wgsl = `
        struct U { res: vec2f, time: f32, waterOn: f32, bloom: f32, pad: vec3f };
        @group(0) @binding(0) var samp: sampler;
        @group(0) @binding(1) var texW: texture_2d<f32>;
        @group(0) @binding(2) var texP: texture_2d<f32>;
        @group(0) @binding(3) var<uniform> uni: U;
        struct VSOut { @builtin(position) pos: vec4f, @location(0) uv: vec2f };
        @vertex fn vs(@location(0) a: vec2f) -> VSOut { var o:VSOut; o.pos = vec4f(a,0,1); o.uv = (a+vec2f(1,1))*0.5; return o; }
        fn pal(idx: f32) -> vec4f { let u=(idx+0.5)/256.0; return textureSample(texP, samp, vec2f(u,0.5)); }
        @fragment fn fs(@location(0) uv: vec2f) -> @location(0) vec4f {
          let uvF = vec2f(uv.x, 1.0-uv.y);
          let px = 1.0/uni.res.x; let py = 1.0/uni.res.y;
          let uvQ = (floor(uvF*uni.res)+0.5)/uni.res;
          let dt = textureSample(texW, samp, uvQ);
          let tidx = floor(dt.r*255.0+0.5);
          var base = pal(tidx);
          // edges darken
          let tL = floor(textureSample(texW, samp, uvQ+vec2f(-px,0)).r*255.0+0.5);
          let tR = floor(textureSample(texW, samp, uvQ+vec2f(px,0)).r*255.0+0.5);
          let tU = floor(textureSample(texW, samp, uvQ+vec2f(0,-py)).r*255.0+0.5);
          let tD = floor(textureSample(texW, samp, uvQ+vec2f(0,py)).r*255.0+0.5);
          let edge = select(0.0, 1.0, abs(tidx-tL)>0.5) + select(0.0, 1.0, abs(tidx-tR)>0.5) + select(0.0,1.0, abs(tidx-tU)>0.5) + select(0.0,1.0, abs(tidx-tD)>0.5);
          base.rgb *= 1.0 - 0.06*min(edge,1.0);
          // water refraction + shading if enabled
          if (tidx==2.0 && uni.waterOn>0.5) {
            var depth: f32 = 0.0;
            for (var i:i32=0; i<6; i=i+1) {
              let yy = uvQ.y + f32(i)*py; if(yy>1.0){ break; }
              let d2 = textureSample(texW, samp, vec2f(uvQ.x, yy));
              depth = depth + select(0.0, 1.0, abs(floor(d2.r*255.0+0.5)-2.0)>0.5);
            }
            base.rgb = base.rgb * (1.0 - depth*0.06);
            let mx = textureSample(texW, samp, uvQ+vec2f(px,0.0)).r - textureSample(texW, samp, uvQ-vec2f(px,0.0)).r;
            let my = textureSample(texW, samp, uvQ+vec2f(0.0,py)).r - textureSample(texW, samp, uvQ-vec2f(0.0,py)).r;
            let normal = normalize(vec3f(-mx*6.0, -my*6.0, 1.0));
            let n = vec2f(sin((uvQ.y + uni.time*0.15)*20.0)*0.0015, cos((uvQ.x - uni.time*0.10)*20.0)*0.0015);
            let offs = n + normal.xy*0.0025;
            let dt2 = textureSample(texW, samp, clamp(uvQ+offs, vec2f(0.0), vec2f(1.0)));
            let tidx2 = floor(dt2.r*255.0+0.5);
            let scene = pal(tidx2).rgb;
            let tint = vec3f(0.15,0.35,0.55);
            base.rgb = mix(base.rgb, scene*1.05 + tint*0.25, 0.45);
          }
          // lamp brighten when aux>0 (dt.g)
          if (tidx==17.0 && dt.g>0.0) { base.rgb += vec3f(0.15,0.12,0.02); }
          // gases minor flicker
          if (tidx==7.0 || tidx==23.0 || tidx==30.0) { base.rgb += vec3f(0.02*sin((uvQ.x+uvQ.y+uni.time)*80.0)); }
          // simple bloom from bright emitters
          var bloomAdd: vec3f = vec3f(0.0);
          if (uni.bloom > 0.01) {
            let isEmitCenter = (tidx==6.0) || (tidx==4.0) || (tidx==13.0) || ((tidx==17.0) && dt.g>0.0);
            if (isEmitCenter) { bloomAdd += base.rgb * 0.35; }
            for (var oy:i32=-1; oy<=1; oy=oy+1) { for (var ox:i32=-1; ox<=1; ox=ox+1) {
              let uvN = uvQ + vec2f(f32(ox), f32(oy)) * vec2f(px,py) * 2.0;
              let dN = textureSample(texW, samp, clamp(uvN, vec2f(0.0), vec2f(1.0)));
              let iN = floor(dN.r*255.0+0.5);
              let emit = (iN==6.0) || (iN==4.0) || (iN==13.0) || ((iN==17.0) && dN.g>0.0);
              if (emit) { bloomAdd += pal(iN).rgb * 0.06; }
            }}
            base.rgb += bloomAdd * uni.bloom;
          }
          return vec4f(base.rgb, 1.0);
        }`;
      const module = wgpuDevice.createShaderModule({ code: wgsl });
      wgpuPipeline = wgpuDevice.createRenderPipeline({
        layout: 'auto',
        vertex: { module, entryPoint:'vs', buffers:[{ arrayStride: 8, attributes:[{ shaderLocation:0, offset:0, format:'float32x2'}] }] },
        fragment: { module, entryPoint:'fs', targets:[{ format: wgpuFormat }] },
        primitive:{ topology:'triangle-strip' }
      });
      wgpuReady=true;
      ensureWorldWGPUSize();
    }catch(e){ wgpuError=e; wgpuReady=false; }
  }
  function ensureWorldWGPUSize(){ if(!wgpuCanvas||!wgpuDevice) return; if(wgpuCanvas.width!==W||wgpuCanvas.height!==H){ wgpuCanvas.width=W; wgpuCanvas.height=H; wgpuCtx.configure({ device: wgpuDevice, format: wgpuFormat, alphaMode:'premultiplied' }); wgpuWorldTex.destroy(); wgpuWorldTex = wgpuDevice.createTexture({ size:{width:W,height:H}, format:'rgba8unorm', usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST }); }
    // compute row pitch and staging buffer
    const row = W*4; const pitch = Math.ceil(row/256)*256; if(pitch!==wgpuWorldRowPitch){ wgpuWorldRowPitch=pitch; wgpuWorldUpload=new Uint8Array(pitch*H); }
  }
  function layoutWorldWGPU(){ if(!wgpuCanvas) return; // style size in CSS pixels
    wgpuCanvas.style.width = (W*cell) + 'px';
    wgpuCanvas.style.height = (H*cell) + 'px';
    // apply pan/zoom (offX/offY are device pixels; convert to CSS px by DPI)
    const tx = offX / DPI; const ty = offY / DPI;
    wgpuCanvas.style.transformOrigin = 'top left';
    wgpuCanvas.style.transform = `translate(${tx}px, ${ty}px) scale(${scale})`;
  }
  function uploadWorldDataWGPU(){ if(!wgpuReady) return; ensureWorldWGPUSize();
    // fill upload buffer with t, aux
    let off=0; const row=W*4; for(let y=0;y<H;y++){ const rowOff=y*wgpuWorldRowPitch; for(let x=0;x<W;x++){ const i=idx(x,y); const t=grid[i]; const a=aux[i]&255; const p=rowOff + x*4; wgpuWorldUpload[p]=t; wgpuWorldUpload[p+1]=a; wgpuWorldUpload[p+2]=0; wgpuWorldUpload[p+3]=255; } }
    wgpuDevice.queue.writeTexture({ texture: wgpuWorldTex }, wgpuWorldUpload, { bytesPerRow: wgpuWorldRowPitch }, { width:W, height:H });
    // update uniforms
    const waterOn = ($waterFX && $waterFX.checked) ? 1.0 : 0.0;
    const bloom = ($bloom && $bloom.checked) ? 0.85 : 0.0;
    const ub=new Float32Array([W, H, performance.now()/1000.0, waterOn, bloom, 0, 0, 0]);
    wgpuDevice.queue.writeBuffer(wgpuUniformBuf, 0, ub);
    // bind group
    const viewW = wgpuWorldTex.createView(); const viewP = wgpuPalTex.createView();
    wgpuBindGroup = wgpuDevice.createBindGroup({ layout: wgpuPipeline.getBindGroupLayout(0), entries:[
      { binding:0, resource: wgpuSampler },
      { binding:1, resource: viewW },
      { binding:2, resource: viewP },
      { binding:3, resource: { buffer: wgpuUniformBuf } }
    ]});
  }
  function renderWorldWGPU(){ if(!wgpuReady){ return; } uploadWorldDataWGPU(); const encoder = wgpuDevice.createCommandEncoder(); const pass = encoder.beginRenderPass({ colorAttachments:[{ view: wgpuCtx.getCurrentTexture().createView(), loadOp:'clear', storeOp:'store', clearValue:{r:0,g:0,b:0,a:1} }] }); pass.setPipeline(wgpuPipeline); pass.setVertexBuffer(0, wgpuVertexBuf); pass.setBindGroup(0, wgpuBindGroup); pass.draw(4,1,0,0); pass.end(); wgpuDevice.queue.submit([encoder.finish()]); }

  function ensureBuffer(){
    if(!buf || buf.width!==W || buf.height!==H){
      buf = document.createElement('canvas'); buf.width = W; buf.height = H;
      bctx = buf.getContext('2d', { alpha:false }); bctx.imageSmoothingEnabled = false;
    }
    if(!glow || glow.width!==W || glow.height!==H){
      glow = document.createElement('canvas'); glow.width = W; glow.height = H;
      gctx = glow.getContext('2d', { alpha:true }); gctx.imageSmoothingEnabled = false;
    }
    if(!waterMaskArr || waterMaskArr.length!==W*H*4){ waterMaskArr=new Uint8Array(W*H*4); }
  }
  function initWorldGL(){
    if(glWorld) return;
    glWorldCanvas=document.createElement('canvas'); glWorldCanvas.width=W; glWorldCanvas.height=H;
    glWorld=glWorldCanvas.getContext('webgl',{alpha:false,premultipliedAlpha:false}); if(!glWorld) return;
    const vs=`attribute vec2 a; varying vec2 v; void main(){ v=(a+1.0)*0.5; gl_Position=vec4(a,0.0,1.0); }`;
    const fs=`precision mediump float; varying vec2 v; uniform sampler2D d; uniform sampler2D pal; uniform vec2 r; uniform float t;
    float eq(float a, float b){ return step(0.5, 1.0 - abs(a-b)); }
    vec4 samplePal(float idx){ float u=(idx+0.5)/256.0; return texture2D(pal, vec2(u,0.5)); }
    void main(){ vec2 uv=v; vec2 uvF = vec2(uv.x, 1.0 - uv.y);
      // snap to texel centers to avoid shimmering/offset
      vec2 uvQ = (floor(uvF * r) + 0.5) / r;
      vec4 dt=texture2D(d, uvQ); float tidx=floor(dt.r*255.0+0.5);
      vec4 base=samplePal(tidx);
      // outlines for boundaries
      float px=1.0/r.x, py=1.0/r.y;
      float tL=floor(texture2D(d, uvQ+vec2(-px,0.0)).r*255.0+0.5);
      float tR=floor(texture2D(d, uvQ+vec2(px,0.0)).r*255.0+0.5);
      float tU=floor(texture2D(d, uvQ+vec2(0.0,-py)).r*255.0+0.5);
      float tD=floor(texture2D(d, uvQ+vec2(0.0,py)).r*255.0+0.5);
      float edge = 0.0;
      edge += step(0.5, abs(tidx - tL)); edge += step(0.5, abs(tidx - tR)); edge += step(0.5, abs(tidx - tU)); edge += step(0.5, abs(tidx - tD));
      base.rgb *= 1.0 - 0.06*min(edge,1.0);
      // fake directional light using simple normal from neighbor differences
      vec2 grad = vec2(step(0.5, abs(tidx-tR)) - step(0.5, abs(tidx-tL)), step(0.5, abs(tidx-tD)) - step(0.5, abs(tidx-tU)));
      vec3 nrm = normalize(vec3(grad, 1.0));
      vec3 L = normalize(vec3(0.5, 0.7, 1.0));
      float ndl = clamp(dot(nrm, L)*0.35 + 0.75, 0.0, 1.25);
      base.rgb *= ndl;
      // water shading
      if (tidx==2.0){
        float depth=0.0; for(int i=0;i<6;i++){ float yy = uvQ.y + float(i)*py; if(yy>1.0) break; vec4 d2=texture2D(d, vec2(uvQ.x, yy)); depth += step(0.5, 1.0-abs(floor(d2.r*255.0+0.5)-2.0)); }
        base.rgb *= (1.0 - depth*0.06);
        // surface highlight
        vec4 up=texture2D(d, uvQ + vec2(0.0,-py)); if(abs(floor(up.r*255.0+0.5)-2.0)>0.5) base.rgb += vec3(0.05,0.07,0.1);
        // small ripple
        float rip = sin((uvQ.y+t*0.3)*50.0)*0.015 + cos((uvQ.x-t*0.2)*40.0)*0.015; base.rgb = mix(base.rgb, base.rgb*1.05, rip*0.5+0.5);
      }
      // lamp brighten
      if (tidx==17.0 && dt.g>0.0){ base.rgb += vec3(0.18,0.15,0.03); }
      // fire/lava/spark emissive tint
      if (tidx==6.0 || tidx==4.0 || tidx==13.0) { base.rgb += vec3(0.08,0.04,0.01); }
      // gas smoothing
      if (tidx==7.0 || tidx==23.0 || tidx==30.0){ base.rgb += vec3(0.02*sin((uvQ.x+uvQ.y+t)*80.0)); }
      gl_FragColor=vec4(base.rgb,1.0); }`;
    const sh=(src,type)=>{ const s=glWorld.createShader(type); glWorld.shaderSource(s,src); glWorld.compileShader(s); if(!glWorld.getShaderParameter(s, glWorld.COMPILE_STATUS)){ console.warn('GL world shader compile error:', glWorld.getShaderInfoLog(s)); } return s; };
    const p=glWorld.createProgram(); glWorld.attachShader(p, sh(vs, glWorld.VERTEX_SHADER)); glWorld.attachShader(p, sh(fs, glWorld.FRAGMENT_SHADER)); glWorld.linkProgram(p); if(!glWorld.getProgramParameter(p, glWorld.LINK_STATUS)){ console.warn('GL world link error:', glWorld.getProgramInfoLog(p)); return; } glWorld.useProgram(p); glWorldProg=p;
    glWorldPosLoc=glWorld.getAttribLocation(p,'a'); glWorldResLoc=glWorld.getUniformLocation(p,'r'); glWorldTimeLoc=glWorld.getUniformLocation(p,'t'); glWorldDataLoc=glWorld.getUniformLocation(p,'d'); glWorldPalLoc=glWorld.getUniformLocation(p,'pal');
    glWorldBuf=glWorld.createBuffer(); glWorld.bindBuffer(glWorld.ARRAY_BUFFER, glWorldBuf); const quad=new Float32Array([-1,-1, 1,-1, -1,1, 1,1]); glWorld.bufferData(glWorld.ARRAY_BUFFER, quad, glWorld.STATIC_DRAW);
    glWorld.enableVertexAttribArray(glWorldPosLoc); glWorld.vertexAttribPointer(glWorldPosLoc, 2, glWorld.FLOAT, false, 0, 0);
    // textures
    glWorldDataTex=glWorld.createTexture(); glWorld.bindTexture(glWorld.TEXTURE_2D, glWorldDataTex); glWorld.texParameteri(glWorld.TEXTURE_2D,glWorld.TEXTURE_MIN_FILTER,glWorld.NEAREST); glWorld.texParameteri(glWorld.TEXTURE_2D,glWorld.TEXTURE_MAG_FILTER,glWorld.NEAREST); glWorld.texParameteri(glWorld.TEXTURE_2D,glWorld.TEXTURE_WRAP_S,glWorld.CLAMP_TO_EDGE); glWorld.texParameteri(glWorld.TEXTURE_2D,glWorld.TEXTURE_WRAP_T,glWorld.CLAMP_TO_EDGE);
    glWorldPalTex=glWorld.createTexture(); glWorld.bindTexture(glWorld.TEXTURE_2D, glWorldPalTex); glWorld.texParameteri(glWorld.TEXTURE_2D,glWorld.TEXTURE_MIN_FILTER,glWorld.NEAREST); glWorld.texParameteri(glWorld.TEXTURE_2D,glWorld.TEXTURE_MAG_FILTER,glWorld.NEAREST); glWorld.texParameteri(glWorld.TEXTURE_2D,glWorld.TEXTURE_WRAP_S,glWorld.CLAMP_TO_EDGE); glWorld.texParameteri(glWorld.TEXTURE_2D,glWorld.TEXTURE_WRAP_T,glWorld.CLAMP_TO_EDGE);
    // palette upload
    const palW=256, palH=1; worldPalArr=new Uint8Array(palW*4);
    for(let i=0;i<256;i++){ let hex=0; if(C[i]!=null) hex=C[i]; const o=i*4; worldPalArr[o]=(hex>>16)&255; worldPalArr[o+1]=(hex>>8)&255; worldPalArr[o+2]=hex&255; worldPalArr[o+3]=255; }
    glWorld.bindTexture(glWorld.TEXTURE_2D, glWorldPalTex); glWorld.texImage2D(glWorld.TEXTURE_2D,0,glWorld.RGBA,256,1,0,glWorld.RGBA,glWorld.UNSIGNED_BYTE, worldPalArr);
  }
  function ensureWorldGLSize(){ if(!glWorldCanvas) return; if(glWorldCanvas.width!==W||glWorldCanvas.height!==H){ glWorldCanvas.width=W; glWorldCanvas.height=H; } }
  function uploadWorldData(){ if(!worldDataArr || worldDataArr.length!==W*H*4) worldDataArr=new Uint8Array(W*H*4); let p=0; for(let y=0;y<H;y++){ for(let x=0;x<W;x++){ const i=idx(x,y); const t=grid[i]; const a=aux[i]&255; worldDataArr[p++]=t; worldDataArr[p++]=a; worldDataArr[p++]=0; worldDataArr[p++]=255; } } }
  function renderWorldGL(){ initWorldGL(); if(!glWorld) { // fallback silently
      if(!frame||frame.width!==W||frame.height!==H) frame=img();
      const data=frame.data; let p=0; for(let y=0;y<H;y++){ for(let x=0;x<W;x++){ const t=grid[idx(x,y)]; let hex=C[t]||0; data[p++]=(hex>>16)&255; data[p++]=(hex>>8)&255; data[p++]=hex&255; data[p++]=255; } } bctx.putImageData(frame,0,0); sceneSource=buf; return; }
    ensureWorldGLSize(); uploadWorldData();
    glWorld.viewport(0,0,W,H); glWorld.useProgram(glWorldProg);
    glWorld.uniform2f(glWorldResLoc, W*1.0, H*1.0); glWorld.uniform1f(glWorldTimeLoc, performance.now()/1000.0);
    glWorld.activeTexture(glWorld.TEXTURE0); glWorld.bindTexture(glWorld.TEXTURE_2D, glWorldDataTex); glWorld.texImage2D(glWorld.TEXTURE_2D,0,glWorld.RGBA,W,H,0,glWorld.RGBA,glWorld.UNSIGNED_BYTE, worldDataArr); glWorld.uniform1i(glWorldDataLoc, 0);
    glWorld.activeTexture(glWorld.TEXTURE1); glWorld.bindTexture(glWorld.TEXTURE_2D, glWorldPalTex); glWorld.uniform1i(glWorldPalLoc, 1);
    glWorld.bindBuffer(glWorld.ARRAY_BUFFER, glWorldBuf); glWorld.enableVertexAttribArray(glWorldPosLoc); glWorld.vertexAttribPointer(glWorldPosLoc,2,glWorld.FLOAT,false,0,0); glWorld.drawArrays(glWorld.TRIANGLE_STRIP, 0, 4);
  }
  function initWaterGL(){
    if(wgl) return;
    wglCanvas=document.createElement('canvas'); wglCanvas.width=W; wglCanvas.height=H;
    wgl=wglCanvas.getContext('webgl',{premultipliedAlpha:false, alpha:true}); if(!wgl) return;
    const vs=`attribute vec2 a; varying vec2 v; void main(){ v=(a+1.0)*0.5; gl_Position=vec4(a,0.0,1.0); }`;
    const fs=`precision mediump float; varying vec2 v; uniform sampler2D s; uniform sampler2D m; uniform vec2 r; uniform float t; 
      void main(){ vec2 vf = vec2(v.x, 1.0 - v.y); vec2 uvQ = (floor(vf * r) + 0.5) / r; float wm = texture2D(m, uvQ).r; if(wm<0.01) discard; 
        vec2 uv=uvQ; vec2 n = vec2(sin((uvQ.y + t*0.15)*20.0)*0.0015, cos((uvQ.x - t*0.10)*20.0)*0.0015);
        float px=1.0/r.x, py=1.0/r.y; float mx = texture2D(m, uvQ+vec2(px,0.0)).r - texture2D(m, uvQ-vec2(px,0.0)).r; float my = texture2D(m, uvQ+vec2(0.0,py)).r - texture2D(m, uvQ-vec2(0.0,py)).r; 
        vec3 normal = normalize(vec3(-mx*6.0, -my*6.0, 1.0)); vec2 offs = n + normal.xy*0.0025; vec3 scene=texture2D(s, uv+offs).rgb; 
        vec3 tint = vec3(0.15,0.35,0.55); vec3 col = mix(scene, scene*1.05 + tint*0.25, 0.45);
        float spec = pow(max(0.0, dot(normal, normalize(vec3(0.3,0.6,0.75)))), 16.0); col += vec3(0.7,0.8,0.9)*spec*0.35; gl_FragColor=vec4(col, clamp(wm*0.9, 0.25, 0.9)); }`;
    const compile=(src,type)=>{ const s=wgl.createShader(type); wgl.shaderSource(s,src); wgl.compileShader(s); if(!wgl.getShaderParameter(s,wgl.COMPILE_STATUS)){ console.warn('GLSL compile error:', wgl.getShaderInfoLog(s)); } return s; };
    const link=(vsSrc,fsSrc)=>{ const p=wgl.createProgram(); const v=compile(vsSrc,wgl.VERTEX_SHADER); const f=compile(fsSrc,wgl.FRAGMENT_SHADER); wgl.attachShader(p,v); wgl.attachShader(p,f); wgl.linkProgram(p); if(!wgl.getProgramParameter(p,wgl.LINK_STATUS)){ console.warn('Program link error:', wgl.getProgramInfoLog(p)); } return p; };
    const p=link(vs,fs); wgl.useProgram(p); wglProg=p;
    wglPosLoc=wgl.getAttribLocation(p,'a'); wglTimeLoc=wgl.getUniformLocation(p,'t'); wglResLoc=wgl.getUniformLocation(p,'r'); wglSceneLoc=wgl.getUniformLocation(p,'s'); wglMaskLoc=wgl.getUniformLocation(p,'m');
    wglBuf=wgl.createBuffer(); wgl.bindBuffer(wgl.ARRAY_BUFFER, wglBuf); const quad=new Float32Array([-1,-1, 1,-1, -1,1, 1,1]); wgl.bufferData(wgl.ARRAY_BUFFER, quad, wgl.STATIC_DRAW);
    wgl.enableVertexAttribArray(wglPosLoc); wgl.vertexAttribPointer(wglPosLoc, 2, wgl.FLOAT, false, 0, 0);
    // textures
    wglSceneTex=wgl.createTexture(); wgl.bindTexture(wgl.TEXTURE_2D, wglSceneTex); wgl.texParameteri(wgl.TEXTURE_2D,wgl.TEXTURE_MIN_FILTER,wgl.LINEAR); wgl.texParameteri(wgl.TEXTURE_2D,wgl.TEXTURE_MAG_FILTER,wgl.LINEAR); wgl.texParameteri(wgl.TEXTURE_2D,wgl.TEXTURE_WRAP_S,wgl.CLAMP_TO_EDGE); wgl.texParameteri(wgl.TEXTURE_2D,wgl.TEXTURE_WRAP_T,wgl.CLAMP_TO_EDGE);
    wglMaskTex=wgl.createTexture(); wgl.bindTexture(wgl.TEXTURE_2D, wglMaskTex); wgl.texParameteri(wgl.TEXTURE_2D,wgl.TEXTURE_MIN_FILTER,wgl.NEAREST); wgl.texParameteri(wgl.TEXTURE_2D,wgl.TEXTURE_MAG_FILTER,wgl.NEAREST); wgl.texParameteri(wgl.TEXTURE_2D,wgl.TEXTURE_WRAP_S,wgl.CLAMP_TO_EDGE); wgl.texParameteri(wgl.TEXTURE_2D,wgl.TEXTURE_WRAP_T,wgl.CLAMP_TO_EDGE);
    // bloom shader (simplified kernel)
    const fsBloom=`precision mediump float; varying vec2 v; uniform sampler2D s; uniform vec2 r; uniform float t; 
      float luma(vec3 c){ return dot(c, vec3(0.2126,0.7152,0.0722)); }
      void main(){ vec2 vf=vec2(v.x,1.0-v.y); vec2 px=vec2(1.0/r.x, 1.0/r.y); vec3 sum=vec3(0.0);
        for(int oy=-1; oy<=1; oy++){
          for(int ox=-1; ox<=1; ox++){
            vec2 uv=vf+vec2(float(ox),float(oy))*px*2.0; vec3 c=texture2D(s,uv).rgb; float b=max(0.0, luma(c)-0.65);
            float w=0.11; if(ox==0 && oy==0) w=0.18; sum+=c*b*w; }
        }
        gl_FragColor=vec4(sum, clamp(length(sum),0.0,0.9)); }`;
    const p2=link(vs,fsBloom); wglBloomProg=p2; wglBloomPosLoc=wgl.getAttribLocation(p2,'a'); wglBloomResLoc=wgl.getUniformLocation(p2,'r'); wglBloomSceneLoc=wgl.getUniformLocation(p2,'s'); wglBloomTimeLoc=wgl.getUniformLocation(p2,'t');
  }
  function ensureWaterGLSize(){ if(!wglCanvas) return; if(wglCanvas.width!==W||wglCanvas.height!==H){ wglCanvas.width=W; wglCanvas.height=H; } }
  function buildWaterMask(){ if(!waterMaskArr) return; let p=0; for(let y=0;y<H;y++){ for(let x=0;x<W;x++){ const on = (grid[idx(x,y)]===T.WATER)?255:0; waterMaskArr[p++]=on; waterMaskArr[p++]=on; waterMaskArr[p++]=on; waterMaskArr[p++]=255; } } }
  function renderWaterFX(){ if(!$waterFX.checked) return; if(!wgl) initWaterGL(); if(!wgl) return; ensureWaterGLSize(); buildWaterMask();
    // upload scene from GL world
    const src = sceneSource || buf;
    wgl.activeTexture(wgl.TEXTURE0); wgl.bindTexture(wgl.TEXTURE_2D, wglSceneTex); wgl.pixelStorei(wgl.UNPACK_FLIP_Y_WEBGL, false); wgl.texImage2D(wgl.TEXTURE_2D,0,wgl.RGBA,wgl.RGBA,wgl.UNSIGNED_BYTE, src);
    // upload mask
    wgl.activeTexture(wgl.TEXTURE1); wgl.bindTexture(wgl.TEXTURE_2D, wglMaskTex); wgl.pixelStorei(wgl.UNPACK_FLIP_Y_WEBGL, false); wgl.texImage2D(wgl.TEXTURE_2D,0,wgl.RGBA,W,H,0,wgl.RGBA,wgl.UNSIGNED_BYTE, waterMaskArr);
    // draw
    wgl.viewport(0,0,W,H); wgl.useProgram(wglProg); wgl.uniform1i(wglSceneLoc, 0); wgl.uniform1i(wglMaskLoc, 1); wgl.uniform2f(wglResLoc, W*1.0, H*1.0); wgl.uniform1f(wglTimeLoc, performance.now()/1000.0);
    // clear to fully transparent every frame to avoid trails
    wgl.disable(wgl.BLEND); wgl.clearColor(0,0,0,0); wgl.clear(wgl.COLOR_BUFFER_BIT);
    wgl.bindBuffer(wgl.ARRAY_BUFFER, wglBuf); wgl.enableVertexAttribArray(wglPosLoc); wgl.vertexAttribPointer(wglPosLoc,2,wgl.FLOAT,false,0,0); wgl.drawArrays(wgl.TRIANGLE_STRIP, 0, 4);
    // composite
    ctx.globalCompositeOperation='source-over'; ctx.globalAlpha=1; ctx.drawImage(wglCanvas, 0,0);
  }
  function renderBloomFX(){ if(!$bloom.checked) return; if(!wgl) initWaterGL(); if(!wgl) return; ensureWaterGLSize();
    // upload scene texture
    const src = sceneSource || buf;
    wgl.activeTexture(wgl.TEXTURE0); wgl.bindTexture(wgl.TEXTURE_2D, wglSceneTex); wgl.pixelStorei(wgl.UNPACK_FLIP_Y_WEBGL, false); wgl.texImage2D(wgl.TEXTURE_2D,0,wgl.RGBA,wgl.RGBA,wgl.UNSIGNED_BYTE, src);
    // draw bloom into overlay canvas
    wgl.viewport(0,0,W,H); wgl.useProgram(wglBloomProg); wgl.uniform1i(wglBloomSceneLoc, 0); wgl.uniform2f(wglBloomResLoc, W*1.0, H*1.0); wgl.uniform1f(wglBloomTimeLoc, performance.now()/1000.0);
    wgl.disable(wgl.BLEND); wgl.clearColor(0,0,0,0); wgl.clear(wgl.COLOR_BUFFER_BIT);
    wgl.bindBuffer(wgl.ARRAY_BUFFER, wglBuf); wgl.enableVertexAttribArray(wglPosLoc); wgl.vertexAttribPointer(wglPosLoc,2,wgl.FLOAT,false,0,0); wgl.drawArrays(wgl.TRIANGLE_STRIP, 0, 4);
    // additive composite on main
    ctx.globalCompositeOperation='lighter'; ctx.globalAlpha=0.85; ctx.drawImage(wglCanvas,0,0); ctx.globalAlpha=1; ctx.globalCompositeOperation='source-over';
  }
  function lerpColor(a,b,t){ const ar=(a>>16)&255,ag=(a>>8)&255,ab=a&255; const br=(b>>16)&255,bg=(b>>8)&255,bb=b&255; const r=ar+(br-ar)*t|0,g=ag+(bg-ag)*t|0,b2=ab+(bb-ab)*t|0; return (r<<16)|(g<<8)|b2; }
  function rgb(hex){ return `rgb(${(hex>>16)&255},${(hex>>8)&255},${hex&255})`; }
  function tweak(hex,d){ let r=(hex>>16)&255,g=(hex>>8)&255,b=hex&255; const cl=v=>v<0?0:v>255?255:v; return ((cl(r+d))<<16)|((cl(g+d))<<8)|(cl(b+d)); }

  function redraw(){
    ensureBuffer();
    if(USE_GL_WORLD){
      renderWorldGL();
      sceneSource = glWorldCanvas;
    } else {
      if(!frame||frame.width!==W||frame.height!==H) frame=img();
      const data=frame.data; let p=0;
      for(let y=0;y<H;y++){
        for(let x=0;x<W;x++){
          const t=grid[idx(x,y)];
          let hex=C[t]||0;
          if(t===T.SAND||t===T.STONE||t===T.METAL||t===T.ICE||t===T.ROAD||t===T.FARMLAND||t===T.PILE||t===T.WOOD||t===T.GLASS||t===T.SNOW){
            const d=((x*13+y*7)%8)-4; hex=tweak(hex,d);
          }
          if(t===T.WATER){
            let depth=0; for(let yy=y; yy<H && grid[idx(x,yy)]===T.WATER && depth<6; yy++) depth++;
            hex=tweak(hex, -depth*3);
            if(y>0 && grid[idx(x,y-1)]!==T.WATER) hex=tweak(hex, 8);
          }
          if(SOLID.has(t)){
            let shade=0;
            if(y>0 && SOLID.has(grid[idx(x,y-1)])) shade-=10; else shade+=4;
            if(x>0 && SOLID.has(grid[idx(x-1,y)])) shade-=4;
            hex=tweak(hex, shade);
          }
          if(t===T.LAMP && aux[idx(x,y)]>0){ hex=tweak(C[T.LAMP], 40); }
          if(t===T.SMOKE||t===T.STEAM||t===T.GAS){ hex=tweak(hex, 6-((x+y)&3)); }
          data[p++]=(hex>>16)&255; data[p++]=(hex>>8)&255; data[p++]=hex&255; data[p++]=255;
        }
      }
      bctx.putImageData(frame,0,0);
      sceneSource = buf;
    }

    // Build glow overlay (emitters and water sparkle)
    gctx.setTransform(1,0,0,1,0,0); gctx.clearRect(0,0,glow.width,glow.height);
    gctx.globalCompositeOperation='lighter';
    const drawGlow=(gx,gy,color,r,alpha)=>{
      const grad=gctx.createRadialGradient(gx+0.5,gy+0.5,0, gx+0.5,gy+0.5,r);
      const rc=(color>>16)&255, gc=(color>>8)&255, bc=color&255;
      grad.addColorStop(0, `rgba(${rc},${gc},${bc},${alpha})`);
      grad.addColorStop(1, `rgba(${rc},${gc},${bc},0)`);
      gctx.fillStyle=grad; gctx.fillRect(gx-r, gy-r, r*2, r*2);
    };
    for(let y=0;y<H;y++){
      for(let x=0;x<W;x++){
        const t=grid[idx(x,y)];
        if(t===T.FIRE) drawGlow(x,y,0xFF7A3A, 3, 0.35);
        else if(t===T.LAVA) drawGlow(x,y,0xFF6A2A, 4, 0.30);
        else if(t===T.SPARK) drawGlow(x,y,0xFFFF88, 2, 0.35);
        else if(t===T.LAMP && aux[idx(x,y)]>0) drawGlow(x,y,0xEED16A, 3, 0.25);
        if(t===T.WATER && (y===0 || grid[idx(x,y-1)]!==T.WATER)) drawGlow(x,y,0x88cfff, 2, 0.12);
      }
    }

    // background
    ctx.setTransform(1,0,0,1,0,0); ctx.clearRect(0,0,canvas.width,canvas.height);
    if($day.checked){
      tDay+=0.002; const phase=(Math.sin(tDay)+1)/2;
      const top=lerpColor(0x0a0e14,0x1b2a44,phase); const bot=lerpColor(0x06090e,0x0e1622,phase);
      const g=ctx.createLinearGradient(0,0,0,canvas.height);
      g.addColorStop(0,rgb(top)); g.addColorStop(1,rgb(bot));
      ctx.fillStyle=g; ctx.fillRect(0,0,canvas.width,canvas.height);
    } else { ctx.fillStyle='#0a0e14'; ctx.fillRect(0,0,canvas.width,canvas.height); }

    // world image
    ctx.imageSmoothingEnabled=false;
    ctx.setTransform(DPI*scale*cell,0,0,DPI*scale*cell,offX,offY);
    ctx.drawImage(sceneSource,0,0);
    // glow
    ctx.globalCompositeOperation='lighter'; ctx.globalAlpha=0.85; ctx.drawImage(glow,0,0);
    ctx.globalAlpha=1; ctx.globalCompositeOperation='source-over';
    // draw particles
    if(particles.length){
      ctx.globalCompositeOperation='lighter';
      for(let k=0;k<particles.length;k++){
        const P=particles[k]; const rc=(P.color>>16)&255, gc=(P.color>>8)&255, bc=P.color&255;
        const a=Math.max(0, Math.min(1, P.ttl/40));
        ctx.fillStyle=`rgba(${rc},${gc},${bc},${0.5*a})`;
        ctx.beginPath(); ctx.arc(P.x+0.5, P.y+0.5, P.r||0.5, 0, Math.PI*2); ctx.fill();
      }
      ctx.globalCompositeOperation='source-over';
    }

    // Post FX overlays
    renderWaterFX();
    renderBloomFX();

    // motion heat overlay
    if($heat.checked){
      ctx.globalAlpha=0.25; ctx.fillStyle='#ff8800';
      for(let y=0;y<H;y++) for(let x=0;x<W;x++){
        const a=activity[idx(x,y)]; if(a>0){ ctx.globalAlpha=Math.min(0.3, a/300); ctx.fillRect(x,y,1,1); activity[idx(x,y)]=Math.max(0,a-4); }
      }
      ctx.globalAlpha=1;
    }
    // Portal arrows disabled
    // Subtle vignette
    ctx.setTransform(1,0,0,1,0,0);
    const vg=ctx.createRadialGradient(canvas.width/2, canvas.height/2, Math.min(canvas.width,canvas.height)*0.3, canvas.width/2, canvas.height/2, Math.max(canvas.width,canvas.height)*0.7);
    vg.addColorStop(0,'rgba(0,0,0,0)'); vg.addColorStop(1,'rgba(0,0,0,0.18)');
    ctx.fillStyle=vg; ctx.fillRect(0,0,canvas.width,canvas.height);
  }

  // ===== Loop & stats =====
  let last = performance.now();
  let fpsAcc = 0, frames = 0, fps = 0;
  let simAcc = 0;
  const FIXED_DT = 1000 / 60;
  let stepOnce = false;
  let countAcc = 0;

  function loop(t){
    const dt = t - last; last = t;

    // FPS measurement
    fpsAcc += dt; frames++;
    if (fpsAcc >= 500){
      fps = Math.round((frames * 1000) / fpsAcc);
      frames = 0; fpsAcc = 0;
    }

    // Fixed-step simulation
    if (stepOnce){ step(); stepOnce = false; }
    if (playing){
      const turbo = (shiftDown ? 2 : 1) * speedMul;
      simAcc += dt * turbo;
      let stepsThisFrame = 0;
      while (simAcc >= FIXED_DT){
        step();
        simAcc -= FIXED_DT;
        if (++stepsThisFrame > 120){ simAcc = 0; break; }
      }
    }

    // Periodic UI updates
    countAcc += dt;
    if (countAcc > 600){ updateStats(); if($autosave.checked) autosave(); countAcc = 0; }

    redraw();
    requestAnimationFrame(loop);
  }

  function updateStats(){
    const counts=new Uint32Array(24);
    for(let i=0;i<grid.length;i++) counts[grid[i]]++;
    const parts=grid.length-counts[T.EMPTY];
    $stat.textContent=`${W}×${H} • ${fps} fps • ${parts} parts`;
  }

  // ===== Autosave / Load =====
  function autosave(){
    try{
      const payload={W,H,grid:Array.from(grid),aux:Array.from(aux)};
      localStorage.setItem('stikbox_autosave', JSON.stringify(payload));
    }catch(e){}
  }
  (function tryAutoLoad(){
    try{
      const s=localStorage.getItem('stikbox_autosave');
      if(!s) return;
      const obj=JSON.parse(s);
      if(obj.W&&obj.H&&obj.grid){
        W=obj.W; H=obj.H;
        const pxW=W*cell*DPI, pxH=H*cell*DPI;
        canvas.width=pxW; canvas.height=pxH; canvas.style.width=(W*cell)+'px'; canvas.style.height=(H*cell)+'px';
        grid=Uint8Array.from(obj.grid);
        aux=obj.aux?Uint16Array.from(obj.aux):new Uint16Array(W*H);
        updated=new Uint8Array(W*H); activity=new Uint8Array(W*H);
        npcDir=new Uint8Array(W*H); npcTask=new Uint8Array(W*H); npcInvStone=new Uint16Array(W*H);
        npcRole=new Uint8Array(W*H); npcTX=new Int16Array(W*H); npcTY=new Int16Array(W*H);
      }
    }catch(e){}
  })();

  // ===== Events & bindings =====
  helpBtn.addEventListener('click', ()=>{ helpModal.style.display='grid'; });
  document.getElementById('helpClose').addEventListener('click', ()=>{ helpModal.style.display='none'; });
  helpModal.addEventListener('click', (e)=>{ if(e.target===helpModal) helpModal.style.display='none'; });

  // Materials + role popover
  function showRolePop(){ if(!NPC_ENABLED) return;
    const rect=$peopleBtn.getBoundingClientRect();
    const pop=document.getElementById('rolePop');
    pop.style.left=(rect.left+rect.width/2-180)+'px';
    pop.style.top=(rect.bottom+6)+'px'; pop.classList.add('open');
  }
  function hideRolePop(){ document.getElementById('rolePop').classList.remove('open'); }
  $mat.addEventListener('change', e=>{
    if(e.target && e.target.value){ tool=e.target.value; if(tool==='people'){ showRolePop(); } else { hideRolePop(); } }
  });
  document.querySelector('label[for="m-people"]').addEventListener('click', ()=>{ showRolePop(); });
  document.getElementById('rolePop').addEventListener('click', (e)=>{
    const btn=e.target.closest('button'); if(!btn) return; spawnRole=btn.dataset.role||'random'; hideRolePop();
  });

  // Brush + shape/erase
  $brush.addEventListener('input', ()=>{ brush=+$brush.value; $brushOut.textContent=brush+" px"; });
  $brushDec.addEventListener('click', ()=>{ $brush.value=Math.max(+$brush.value-1, +$brush.min); $brush.dispatchEvent(new Event('input')); });
  $brushInc.addEventListener('click', ()=>{ $brush.value=Math.min(+$brush.value+1, +$brush.max); $brush.dispatchEvent(new Event('input')); });
  $shape.addEventListener('change', e=>{ if(e.target && e.target.value) shape=e.target.value; });
  $erase.addEventListener('change', e=>{ eraseMode=e.target.value; });
  $faceB.addEventListener('change', e=>{ if(e.target && e.target.value) portalFaceB=e.target.value; });
  $faceO.addEventListener('change', e=>{ if(e.target && e.target.value) portalFaceO=e.target.value; });

  // Sim controls
  $toggle.addEventListener('click', ()=>{ playing=!playing; $toggle.textContent=playing?'⏸️ Pause':'▶️ Play'; });
  $step.addEventListener('click', ()=>{ stepOnce=true; });
  $speed.addEventListener('input', ()=>{ speedMul=+$speed.value; });
  // no WebGPU toggle handlers (disabled)

  // Zoom
  function setZoom(z){ scale=clamp(z,0.5,4); }
  $zoomIn.addEventListener('click', ()=> setZoom(scale*1.15));
  $zoomOut.addEventListener('click', ()=> setZoom(scale/1.15));
  $zoomReset.addEventListener('click', ()=>{ scale=1; offX=offY=0; });

  // Save / Load
  $save.addEventListener('click', ()=>{
    const payload = { W,H, grid: Array.from(grid), aux: Array.from(aux) };
    const blob = new Blob([JSON.stringify(payload)], {type:'application/json'});
    const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='stikbox-world.json'; a.click(); URL.revokeObjectURL(a.href);
  });
  $load.addEventListener('click', ()=> $file.click());
  $file.addEventListener('change', async ()=>{
    const f=$file.files[0]; if(!f) return;
    const text=await f.text();
    try{
      const obj=JSON.parse(text);
      if(obj.W&&obj.H&&obj.grid){
        W=obj.W; H=obj.H;
        const pxW=W*cell*DPI, pxH=H*cell*DPI;
        canvas.width=pxW; canvas.height=pxH; canvas.style.width=(W*cell)+'px'; canvas.style.height=(H*cell)+'px';
        grid=Uint8Array.from(obj.grid); aux=obj.aux?Uint16Array.from(obj.aux):new Uint16Array(W*H);
        updated=new Uint8Array(W*H); activity=new Uint8Array(W*H);
        npcDir=new Uint8Array(W*H); npcTask=new Uint8Array(W*H); npcInvStone=new Uint16Array(W*H);
        npcRole=new Uint8Array(W*H); npcTX=new Int16Array(W*H); npcTY=new Int16Array(W*H);
        if(typeof NPC_ENABLED!=='undefined' && !NPC_ENABLED){ purgePeople(); }
        pushHistory('load');
      }
    }catch(e){ alert('Invalid world file'); }
  });

  // Canvas interactions + pinch zoom
  canvas.addEventListener('pointerdown', (e)=>{
    initAudio();
    if($pan.checked){ panning=true; panStart={x:e.clientX,y:e.clientY, offX, offY}; }
    else { painting=true; pushHistory('paint'); paintEvent(e); }
    canvas.setPointerCapture(e.pointerId);
  });
  canvas.addEventListener('pointermove', (e)=>{
    if(panning){ const dx=e.clientX-panStart.x, dy=e.clientY-panStart.y; offX=panStart.offX+dx; offY=panStart.offY+dy; }
    if(painting){ paintEvent(e); if(shiftDown) paintEvent(e); }
  });
  canvas.addEventListener('pointerup', ()=>{ painting=false; panning=false; });
  canvas.addEventListener('pointercancel', ()=>{ painting=false; panning=false; });

  function paintEvent(e){ const g=viewToGrid(e); if(!inb(g.x,g.y)) return; stampAt(g.x,g.y); }

  window.addEventListener('keydown', (e)=>{
    initAudio();
    if(e.key===' '){ e.preventDefault(); playing=!playing; $toggle.textContent=playing?'⏸️ Pause':'▶️ Play'; }
    if(e.key.toLowerCase()==='r'){ grid.fill(0); aux.fill(0); for(let x=0;x<W;x++) grid[idx(x,H-1)]=T.STONE; pushHistory('reset'); }
    if(e.key==='+'){ $brush.value=Math.min(+$brush.value+1, +$brush.max); $brush.dispatchEvent(new Event('input')); }
    if(e.key==='-'){ $brush.value=Math.max(+$brush.value-1, +$brush.min); $brush.dispatchEvent(new Event('input')); }
    if(e.key==='Shift') shiftDown=true;
  });
  window.addEventListener('keyup', (e)=>{ if(e.key==='Shift') shiftDown=false; });

  // Init
  refreshGoalsUI();
  initSizing();
  // Initialize WebGPU world renderer (async, gated by toggle)
  // WebGPU disabled
  speedMul = +$speed.value;
  if(typeof NPC_ENABLED!=='undefined' && !NPC_ENABLED){ purgePeople(); disableNPCsNow(); }
  if(typeof PORTALS_ENABLED!=='undefined' && !PORTALS_ENABLED){ purgePortals(); }
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
